<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.0.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css"><script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script><script class="next-config" data-name="main" type="application/json">{"hostname":"mjy.js.org","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":"ture","style":"default"},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script><meta name="description" content="M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型"><meta property="og:type" content="article"><meta property="og:title" content="【论文阅读 | ICCV 2025 | M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】"><meta property="og:url" content="https://mjy.js.org/2025/12/13/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20%20ICCV%202025%20%20M-SpecGene%EF%BC%9A%E9%9D%A2%E5%90%91%20RGBT%20%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E7%9A%84%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E3%80%91/index.html"><meta property="og:site_name" content="TranquilYu&#39;s Blog"><meta property="og:description" content="M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mjy.js.org/images/image-20251214104330420.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214104451800.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214121527043.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214121726437.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214105659860.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214105714507.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214105737756.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214105752154.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214105825888.png"><meta property="og:image" content="https://mjy.js.org/images/image-20251214105932254.png"><meta property="article:published_time" content="2025-12-13T00:00:00.000Z"><meta property="article:modified_time" content="2025-12-20T23:18:41.183Z"><meta property="article:author" content="MaJianyu"><meta property="article:tag" content="MAE"><meta property="article:tag" content="共享参数"><meta property="article:tag" content="多光谱目标检测"><meta property="article:tag" content="跨参数交互"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://mjy.js.org/images/image-20251214104330420.png"><link rel="canonical" href="https://mjy.js.org/2025/12/13/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20%20ICCV%202025%20%20M-SpecGene%EF%BC%9A%E9%9D%A2%E5%90%91%20RGBT%20%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E7%9A%84%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E3%80%91/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://mjy.js.org/2025/12/13/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20%20ICCV%202025%20%20M-SpecGene%EF%BC%9A%E9%9D%A2%E5%90%91%20RGBT%20%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E7%9A%84%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E3%80%91/","path":"2025/12/13/【论文阅读  ICCV 2025  M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】/","title":"【论文阅读 | ICCV 2025 | M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>【论文阅读 | ICCV 2025 | M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】 | TranquilYu's Blog</title><script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script><script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script><script src="/js/pjax.js" defer></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script><script src="/js/third-party/search/local-search.js" defer></script><script src="/js/third-party/fancybox.js" defer></script><script src="/js/third-party/pace.js" defer></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":"flase","tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js" defer></script><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer"><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style><link rel="alternate" href="/atom.xml" title="TranquilYu's Blog" type="application/atom+xml">
</head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">TranquilYu's Blog</p><i class="logo-line"></i></a></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF%E4%B8%8E%E5%8A%A8%E6%9C%BA"><span class="nav-text">1. 研究背景与动机</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-RGBT-%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="nav-text">1.1 RGBT 多光谱视觉的重要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E7%8E%B0%E6%9C%89%E8%8C%83%E5%BC%8F%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">1.2 现有范式的局限性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E4%BA%BA%E5%B7%A5%E5%BD%92%E7%BA%B3%E5%81%8F%E7%BD%AE%EF%BC%88Artificial-Inductive-Bias%EF%BC%89"><span class="nav-text">1.2.1 人工归纳偏置（Artificial Inductive Bias）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-%E6%A8%A1%E6%80%81%E5%81%8F%E7%BD%AE%EF%BC%88Modality-Bias%EF%BC%89"><span class="nav-text">1.2.2 模态偏置（Modality Bias）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-%E6%95%B0%E6%8D%AE%E7%93%B6%E9%A2%88%EF%BC%88Data-Bottleneck%EF%BC%89"><span class="nav-text">1.2.3 数据瓶颈（Data Bottleneck）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E8%8C%83%E5%BC%8F%E7%9A%84%E5%90%AF%E7%A4%BA"><span class="nav-text">1.3 基础模型范式的启示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-%E6%9C%AC%E6%96%87%E8%B4%A1%E7%8C%AE"><span class="nav-text">1.4 本文贡献</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="nav-text">2. 相关工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-RGBT%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E4%BB%BB%E5%8A%A1"><span class="nav-text">2.1 RGBT多光谱视觉任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-RGBT%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B"><span class="nav-text">2.1.1 RGBT目标检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-RGBT%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2"><span class="nav-text">2.1.2 RGBT语义分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-RGBT%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="nav-text">2.1.3 RGBT显著性检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-RGBT%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA"><span class="nav-text">2.1.4 RGBT目标跟踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E4%B8%8E%E8%87%AA%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="nav-text">2.2 基础模型与自监督学习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.2.1 视觉基础模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E5%A4%9A%E6%A8%A1%E6%80%81%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B"><span class="nav-text">2.2.2 多模态基础模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E6%8E%A9%E7%A0%81%E7%AD%96%E7%95%A5%E8%AE%BE%E8%AE%A1"><span class="nav-text">2.2.3 掩码策略设计</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%96%B9%E6%B3%95"><span class="nav-text">3. 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">3.1 整体框架概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%B7%A8%E6%A8%A1%E6%80%81%E7%BB%93%E6%9E%84%E7%A8%80%E7%96%8F%E6%80%A7%EF%BC%88Cross-Modality-Structural-Sparsity-CMSS%EF%BC%89"><span class="nav-text">3.2 跨模态结构稀疏性（Cross-Modality Structural Sparsity, CMSS）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%9B%A0"><span class="nav-text">3.2.1 设计原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-CMSS-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">3.2.2 CMSS 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CMSS-%E6%95%B0%E5%80%BC%E5%90%AB%E4%B9%89"><span class="nav-text">CMSS 数值含义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-CMSS-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%80%A7"><span class="nav-text">3.2.3 CMSS 的数据统计特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-GMM-CMSS-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%8E%A9%E7%A0%81"><span class="nav-text">3.3 GMM-CMSS 渐进式掩码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-text">3.3.1 设计原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-CMSS-%E7%9A%84%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E5%BB%BA%E6%A8%A1%EF%BC%88GMM%EF%BC%89"><span class="nav-text">3.3.2 CMSS 的高斯混合建模（GMM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E5%9F%BA%E4%BA%8E-GMM-%E7%9A%84%E9%87%87%E6%A0%B7%E5%87%BD%E6%95%B0%E4%B8%8E%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%8E%A9%E7%A0%81"><span class="nav-text">3.3.3 基于 GMM 的采样函数与渐进式掩码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-Siamese-%E7%BC%96%E7%A0%81%E4%B8%8E%E8%B7%A8%E6%A8%A1%E6%80%81%E9%87%8D%E5%BB%BA"><span class="nav-text">3.4 Siamese 编码与跨模态重建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-Siamese-%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%8F%8C%E6%A8%A1%E6%80%81%E5%89%8D%E5%90%91%E4%BC%A0%E6%92%AD"><span class="nav-text">3.4.1 Siamese 编码器设计与双模态前向传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E8%B7%A8%E6%A8%A1%E6%80%81%E8%A7%A3%E7%A0%81%E4%B8%8E%E9%87%8D%E5%BB%BA"><span class="nav-text">3.4.2 跨模态解码与重建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E9%A2%84%E8%AE%AD%E7%BB%83%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0"><span class="nav-text">3.5 预训练目标函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E6%8E%A9%E7%A0%81%E5%9B%BE%E5%83%8F%E5%BB%BA%E6%A8%A1%EF%BC%88MIM%EF%BC%89"><span class="nav-text">3.5.1 掩码图像建模（MIM）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-%E8%B7%A8%E6%A8%A1%E6%80%81%E5%AF%B9%E6%AF%94%E7%BA%A6%E6%9D%9F%EF%BC%88%E8%BE%85%E5%8A%A9%E6%8D%9F%E5%A4%B1%EF%BC%89"><span class="nav-text">3.5.2 跨模态对比约束（辅助损失）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E6%80%BB%E4%BD%93%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0"><span class="nav-text">3.5.3 总体损失函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-%E4%B8%8B%E6%B8%B8%E4%BB%BB%E5%8A%A1%E4%B8%AD%E7%9A%84%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E7%AD%96%E7%95%A5"><span class="nav-text">3.6 下游任务中的特征融合策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-%E4%BA%A4%E5%8F%89%E6%B3%A8%E6%84%8F%E5%8A%9B"><span class="nav-text">3.6.1 交叉注意力</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-%E8%9E%8D%E5%90%88%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="nav-text">3.6.2 融合的核心原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E7%AE%80%E5%8D%95%E7%9B%B8%E5%8A%A0%E8%9E%8D%E5%90%88%EF%BC%9F"><span class="nav-text">3.6.3 为什么采用简单相加融合？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-%E6%96%B9%E6%B3%95%E7%9A%84%E5%88%9B%E6%96%B0%E6%80%BB%E7%BB%93"><span class="nav-text">3.7 方法的创新总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E5%AE%9E%E9%AA%8C%E8%AE%BE%E7%BD%AE"><span class="nav-text">4. 实验设置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E9%A2%84%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%A8%A1%E5%9E%8B%E9%85%8D%E7%BD%AE"><span class="nav-text">4.1 预训练数据与模型配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%B8%8B%E6%B8%B8%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%BE%AE%E8%B0%83%E6%96%B9%E6%A1%88"><span class="nav-text">4.2 下游任务与微调方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-RGBT-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B"><span class="nav-text">4.2.1 RGBT 目标检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-RGBT-%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2"><span class="nav-text">4.2.2 RGBT 语义分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-RGBT-%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="nav-text">4.2.3 RGBT 显著性检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-RGBT-%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA"><span class="nav-text">4.2.4 RGBT 目标跟踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E5%AF%B9%E6%AF%94%E5%9F%BA%E7%BA%BF"><span class="nav-text">4.3 对比基线</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-text">5. 实验结果与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E4%B8%8B%E6%B8%B8%E4%BB%BB%E5%8A%A1%E6%95%B4%E4%BD%93%E6%80%A7%E8%83%BD"><span class="nav-text">5.1 下游任务整体性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-RGBT%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B"><span class="nav-text">5.1.1 RGBT目标检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-RGBT%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2"><span class="nav-text">5.1.2 RGBT语义分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-RGBT%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E6%B5%8B"><span class="nav-text">5.1.3 RGBT显著性检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-RGBT%E7%9B%AE%E6%A0%87%E8%B7%9F%E8%B8%AA"><span class="nav-text">5.1.4 RGBT目标跟踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%B6%88%E8%9E%8D%E5%AE%9E%E9%AA%8C"><span class="nav-text">5.2 消融实验</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-CMSS%E5%BA%A6%E9%87%8F%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"><span class="nav-text">5.2.1 CMSS度量的有效性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E6%B8%90%E8%BF%9B%E5%BC%8F%E8%B0%83%E5%BA%A6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">5.2.2 渐进式调度的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E5%AF%B9%E6%AF%94%E5%AD%A6%E4%B9%A0%E6%8D%9F%E5%A4%B1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">5.2.3 对比学习损失的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E9%A2%84%E8%AE%AD%E7%BB%83%E6%95%B0%E6%8D%AE%E9%87%8F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="nav-text">5.2.4 预训练数据量的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-text">5.3 可视化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%AD%A6%E4%B9%A0%E5%88%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="nav-text">5.3.1 学习到的表示可视化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E6%B3%A8%E6%84%8F%E5%8A%9B%E5%9B%BE%E5%88%86%E6%9E%90"><span class="nav-text">5.3.2 注意力图分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E6%8E%A9%E7%A0%81%E9%87%8D%E5%BB%BA%E8%B4%A8%E9%87%8F"><span class="nav-text">5.3.3 掩码重建质量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E8%B7%A8%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B3%9B%E5%8C%96%E8%83%BD%E5%8A%9B"><span class="nav-text">5.4 跨数据集泛化能力</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E8%AE%A8%E8%AE%BA%E4%B8%8E%E5%88%86%E6%9E%90"><span class="nav-text">6. 讨论与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E4%B8%BA%E4%BB%80%E4%B9%88CMSS%E5%BA%A6%E9%87%8F%E6%9C%89%E6%95%88%EF%BC%9F"><span class="nav-text">6.1 为什么CMSS度量有效？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-GMM%E5%BB%BA%E6%A8%A1%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="nav-text">6.2 GMM建模的必要性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E4%B8%8E%E7%89%B9%E5%AE%9A%E4%BB%BB%E5%8A%A1%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-text">6.3 与特定任务方法的对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90"><span class="nav-text">6.4 计算效率分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E6%A8%A1%E6%80%81%E5%81%8F%E7%BD%AE%E7%9A%84%E9%87%8F%E5%8C%96%E5%88%86%E6%9E%90"><span class="nav-text">6.5 模态偏置的量化分析</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%9C%AA%E6%9D%A5%E5%B7%A5%E4%BD%9C"><span class="nav-text">7. 局限性与未来工作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E5%BD%93%E5%89%8D%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-text">7.1 当前局限性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E6%9C%AA%E6%9D%A5%E7%A0%94%E7%A9%B6%E6%96%B9%E5%90%91"><span class="nav-text">7.2 未来研究方向</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E6%89%A9%E5%B1%95%E5%88%B0%E6%9B%B4%E5%A4%9A%E6%A8%A1%E6%80%81"><span class="nav-text">7.2.1 扩展到更多模态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E8%A7%86%E9%A2%91%E9%A2%84%E8%AE%AD%E7%BB%83"><span class="nav-text">7.2.2 视频预训练</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E5%8F%AF%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BF%A1%E6%81%AF%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1"><span class="nav-text">7.2.3 可学习的信息密度估计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-%E8%BD%BB%E9%87%8F%E5%8C%96%E4%B8%8E%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%83%A8%E7%BD%B2"><span class="nav-text">7.2.4 轻量化与移动端部署</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-5-%E5%BC%80%E6%94%BE%E4%B8%96%E7%95%8C%E6%B3%9B%E5%8C%96"><span class="nav-text">7.2.5 开放世界泛化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-%E7%BB%93%E8%AE%BA"><span class="nav-text">8. 结论</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">MaJianyu</p><div class="site-description" itemprop="description">永远相信，美好的事情即将发生。</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">52</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/majianyu2007" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;majianyu2007" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://space.bilibili.com/600064036" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;600064036" rel="noopener me" target="_blank"><i class="fa-brands fa-bilibili fa-fw"></i>BiliBili</a></span></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://mjy.js.org/2025/12/13/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20%20ICCV%202025%20%20M-SpecGene%EF%BC%9A%E9%9D%A2%E5%90%91%20RGBT%20%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E7%9A%84%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E3%80%91/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="MaJianyu"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="TranquilYu's Blog"><meta itemprop="description" content="永远相信，美好的事情即将发生。"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="【论文阅读 | ICCV 2025 | M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】 | TranquilYu's Blog"><meta itemprop="description" content="M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">【论文阅读 | ICCV 2025 | M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2025-12-13 08:00:00" itemprop="dateCreated datePublished" datetime="2025-12-13T08:00:00+08:00">2025-12-13</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2025-12-21 07:18:41" itemprop="dateModified" datetime="2025-12-21T07:18:41+08:00">2025-12-21</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" itemprop="url" rel="index"><span itemprop="name">论文阅读</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>25k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>46 分钟</span></span></div><div class="post-description">M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型</div></div></header><div class="post-body" itemprop="articleBody"><p><img data-src="/./../images/image-20251214104330420.png" alt="image-20251214104330420"></p><p>题目：M-SpecGene: Generalized Foundation Model for RGBT Multispectral Vision</p><p>会议：International Conference on Computer Vision（ICCV）</p><p>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2507.16318">Link</a></p><p>代码：<a target="_blank" rel="noopener" href="https://github.com/CalayZhou/M-SpecGene">CalayZhou&#x2F;M-SpecGene</a></p><p>年份：2025</p><h1 id="1-研究背景与动机"><a href="#1-研究背景与动机" class="headerlink" title="1. 研究背景与动机"></a>1. 研究背景与动机</h1><h2 id="1-1-RGBT-多光谱视觉的重要性"><a href="#1-1-RGBT-多光谱视觉的重要性" class="headerlink" title="1.1 RGBT 多光谱视觉的重要性"></a>1.1 RGBT 多光谱视觉的重要性</h2><p>RGB-热红外（RGBT）多光谱视觉已成为复杂环境感知的关键技术。相较于单模态RGB视觉，RGBT融合了可见光与热辐射信息，能够在光照变化、恶劣天气、复杂遮挡等场景下提供更鲁棒的感知能力。典型应用包括：</p><ul><li>全天候目标检测与跟踪</li><li>低照度场景理解</li><li>语义分割与显著性检测</li><li>自动驾驶与智能监控</li></ul><p>然而，现有RGBT方法大多采用<strong>逐任务定制</strong>（case-by-case）的研究范式，针对特定任务设计专门的模型架构与融合策略。</p><h2 id="1-2-现有范式的局限性"><a href="#1-2-现有范式的局限性" class="headerlink" title="1.2 现有范式的局限性"></a>1.2 现有范式的局限性</h2><p>当前RGBT研究主要存在以下三个核心问题：</p><h3 id="1-2-1-人工归纳偏置（Artificial-Inductive-Bias）"><a href="#1-2-1-人工归纳偏置（Artificial-Inductive-Bias）" class="headerlink" title="1.2.1 人工归纳偏置（Artificial Inductive Bias）"></a>1.2.1 人工归纳偏置（Artificial Inductive Bias）</h3><p>现阶段许多融合架构针对不同任务手工设计，因此缺乏通用性，泛化能力不足，例如：</p><ul><li>目标检测任务倾向于早期融合或特征金字塔融合</li><li>语义分割偏好逐层注意力融合</li><li>目标跟踪则常采用模板匹配式融合</li></ul><p>这种设计依赖于架构设计者对任务特性的假设，限制了模型跨任务泛化能力，难以迁移到新场景。</p><h3 id="1-2-2-模态偏置（Modality-Bias）"><a href="#1-2-2-模态偏置（Modality-Bias）" class="headerlink" title="1.2.2 模态偏置（Modality Bias）"></a>1.2.2 模态偏置（Modality Bias）</h3><p>RGBT数据存在固有的<strong>信息不平衡</strong>（Information Imbalance）问题：</p><ul><li>RGB模态包含丰富的纹理、颜色、空间结构信息</li><li>热红外模态主要提供温度分布与轮廓信息，细节相对稀疏</li></ul><p>现有方法往往对两模态平等对待，导致训练过程中模型过度依赖信息密度更高的RGB模态，而未能充分利用热红外的互补优势。这种模态偏置在数据量有限时尤为严重。</p><h3 id="1-2-3-数据瓶颈（Data-Bottleneck）"><a href="#1-2-3-数据瓶颈（Data-Bottleneck）" class="headerlink" title="1.2.3 数据瓶颈（Data Bottleneck）"></a>1.2.3 数据瓶颈（Data Bottleneck）</h3><p>与单模态RGB任务拥有海量标注数据不同，RGBT数据集规模普遍较小：</p><ul><li>主流RGBT检测数据集仅含数千至数万对图像</li><li>标注成本高（需同时标注配准的双模态数据）</li><li>场景覆盖有限，难以支撑深度模型的充分学习</li></ul><p>有限的数据规模进一步加剧了过拟合与模态偏置问题。</p><p><img data-src="/./../images/image-20251214104451800.png" alt="image-20251214104451800"></p><h2 id="1-3-基础模型范式的启示"><a href="#1-3-基础模型范式的启示" class="headerlink" title="1.3 基础模型范式的启示"></a>1.3 基础模型范式的启示</h2><p>近年来，计算机视觉领域涌现了一系列成功的基础模型：</p><ul><li><strong>MAE</strong>（Masked Autoencoders）：通过大规模自监督预训练学习通用视觉表示</li><li><strong>CLIP</strong>：在图文配对数据上学习跨模态对齐表示</li><li><strong>SAM</strong>（Segment Anything Model）：实现图像分割的通用能力</li></ul><p>这些工作表明，<strong>自监督预训练 + 大规模数据 + 通用架构</strong>的这种组合能够突破任务特定设计的限制，学习到可迁移的表示。</p><p>然而，多光谱视觉领域尚缺乏此类基础模型。关键挑战在于：</p><ol><li>如何设计适用于RGBT数据特性的自监督学习范式？</li><li>如何克服模态信息不平衡导致的学习偏置？</li><li>如何在有限数据下实现有效的预训练？</li></ol><h2 id="1-4-本文贡献"><a href="#1-4-本文贡献" class="headerlink" title="1.4 本文贡献"></a>1.4 本文贡献</h2><p>针对上述挑战，本文提出<strong>M-SpecGene</strong>（Generalized RGBT MultiSpectral Foundation Model），首次尝试构建面向RGBT多光谱视觉的通用基础模型。主要贡献包括：</p><ol><li><p><strong>提出RGBT统一预训练范式</strong></p><p>将目标检测、语义分割、显著性检测、目标跟踪等任务统一到一个自监督学习框架下，学习模态不变的通用表示（modality-invariant representations）。</p></li><li><p><strong>跨模态结构稀疏性度量（Cross-Modality Structural Sparsity, CMSS）</strong></p><p>首次定量化RGBT数据的信息密度差异，为设计平衡的掩码策略提供理论依据。</p></li><li><p><strong>GMM-CMSS渐进式掩码策略</strong></p><p>基于高斯混合模型（GMM）和CMSS度量，设计灵活的、由易到难的、以目标为中心的渐进掩码策略，有效缓解模态偏置，提升预训练效率。</p></li><li><p><strong>跨任务跨数据集验证</strong></p><p>在<strong>11个数据集</strong>和<strong>4类下游任务</strong>上进行系统评估，证明M-SpecGene在不同任务上的泛化能力与迁移性能。</p></li></ol><hr><h1 id="2-相关工作"><a href="#2-相关工作" class="headerlink" title="2. 相关工作"></a>2. 相关工作</h1><h2 id="2-1-RGBT多光谱视觉任务"><a href="#2-1-RGBT多光谱视觉任务" class="headerlink" title="2.1 RGBT多光谱视觉任务"></a>2.1 RGBT多光谱视觉任务</h2><h3 id="2-1-1-RGBT目标检测"><a href="#2-1-1-RGBT目标检测" class="headerlink" title="2.1.1 RGBT目标检测"></a>2.1.1 RGBT目标检测</h3><p>早期方法采用简单的特征拼接或晚期融合，性能受限。近年来工作聚焦于：</p><ul><li><strong>跨模态注意力机制</strong>：通过注意力模块增强模态交互</li><li><strong>多尺度融合</strong>：在特征金字塔不同层级融合RGB与热红外特征</li><li><strong>动态融合</strong>：根据场景自适应调整融合权重</li></ul><p>代表性工作包括CFT、MBNet、RIFT等，但这些方法设计针对性强，难以直接迁移到其他任务。</p><h3 id="2-1-2-RGBT语义分割"><a href="#2-1-2-RGBT语义分割" class="headerlink" title="2.1.2 RGBT语义分割"></a>2.1.2 RGBT语义分割</h3><p>语义分割需要密集的像素级预测，融合策略更强调：</p><ul><li><strong>逐层特征对齐</strong>：在编码器-解码器架构中逐层融合</li><li><strong>边界增强</strong>：利用热红外轮廓信息改善分割边界</li><li><strong>类别感知融合</strong>：针对不同类别选择不同模态权重</li></ul><p>RTFNet、MFNet等方法在城市场景分割上取得较好效果。</p><h3 id="2-1-3-RGBT显著性检测"><a href="#2-1-3-RGBT显著性检测" class="headerlink" title="2.1.3 RGBT显著性检测"></a>2.1.3 RGBT显著性检测</h3><p>显著性检测旨在定位图像中最吸引注意力的区域：</p><ul><li><strong>互补性建模</strong>：显式建模RGB纹理与热红外亮度的互补性</li><li><strong>跨模态对比</strong>：通过对比学习增强模态差异感知</li></ul><p>APNet、CGFNet等方法利用对比损失提升显著目标检测精度。</p><h3 id="2-1-4-RGBT目标跟踪"><a href="#2-1-4-RGBT目标跟踪" class="headerlink" title="2.1.4 RGBT目标跟踪"></a>2.1.4 RGBT目标跟踪</h3><p>视频目标跟踪需要在时序上保持目标一致性：</p><ul><li><strong>模板匹配</strong>：分别在RGB和热红外上进行模板匹配后融合</li><li><strong>自适应融合</strong>：根据遮挡、光照变化动态调整模态权重</li></ul><p>MANet、CAT等方法在挑战性跟踪场景下表现优异。</p><h2 id="2-2-基础模型与自监督学习"><a href="#2-2-基础模型与自监督学习" class="headerlink" title="2.2 基础模型与自监督学习"></a>2.2 基础模型与自监督学习</h2><h3 id="2-2-1-视觉基础模型"><a href="#2-2-1-视觉基础模型" class="headerlink" title="2.2.1 视觉基础模型"></a>2.2.1 视觉基础模型</h3><ul><li><strong>MAE</strong>：通过高比例掩码重建学习图像表示，展现出强大的迁移能力</li><li><strong>BEiT</strong>：使用离散VAE tokenizer进行掩码图像建模</li><li><strong>SimMIM</strong>：简化掩码策略，直接预测像素值</li></ul><p>这些方法在ImageNet等大规模数据上预训练后，能在多个下游任务上取得优异性能。</p><h3 id="2-2-2-多模态基础模型"><a href="#2-2-2-多模态基础模型" class="headerlink" title="2.2.2 多模态基础模型"></a>2.2.2 多模态基础模型</h3><ul><li><strong>CLIP</strong>：通过对比学习在图文对上学习跨模态表示</li><li><strong>FLAVA</strong>：统一图像、文本、图文配对的多模态预训练</li><li><strong>ImageBind</strong>：将多种模态（视觉、音频、文本等）映射到统一空间</li></ul><p>但这些工作主要针对语义级多模态（如图像-文本），与RGBT这种物理级多模态存在本质差异。</p><h3 id="2-2-3-掩码策略设计"><a href="#2-2-3-掩码策略设计" class="headerlink" title="2.2.3 掩码策略设计"></a>2.2.3 掩码策略设计</h3><p>掩码策略直接影响自监督学习效果：</p><ul><li><strong>随机掩码</strong>（MAE）：简单有效，但未考虑语义信息</li><li><strong>块状掩码</strong>（BEiT）：保持空间连贯性</li><li><strong>注意力引导掩码</strong>：基于注意力图选择重要区域掩码</li></ul><p>然而，现有策略均针对单模态设计，未考虑多模态信息不平衡问题。</p><hr><h1 id="3-方法"><a href="#3-方法" class="headerlink" title="3. 方法"></a>3. 方法</h1><p><img data-src="/./../images/image-20251214121527043.png" alt="image-20251214121527043"></p><h2 id="3-1-整体框架概述"><a href="#3-1-整体框架概述" class="headerlink" title="3.1 整体框架概述"></a>3.1 整体框架概述</h2><p>M-SpecGene 采用基于 <strong>Masked Autoencoders (MAE)</strong> 的 <strong>Siamese Transformer 架构</strong>，以自监督方式学习 <strong>模态不变（modality-invariant）</strong> 的 RGBT 表示。与传统逐任务定制的方法不同，M-SpecGene 通过在预训练阶段显式处理 RGBT 数据的信息不平衡问题，为多个下游任务提供通用的特征提取器。</p><p>整体流程的四个关键步骤：</p><ol><li><p><strong>模态特定 Patch Embedding</strong></p><p>RGB 与热红外图像分别经过 patch embedding 映射为 token 序列，保持模态物理特性的独立性。两个模态独立地分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>×</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">16 \times 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">16</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span> 的 patch 并投影到 768 维特征空间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##mae.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x: torch.Tensor, x2: torch.Tensor, loss1: torch.Tensor, loss2: torch.Tensor, mask: <span class="type">Optional</span>[<span class="built_in">bool</span>] = <span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="literal">False</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().forward(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        B = x.shape[<span class="number">0</span>]  <span class="comment"># batch_size</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># RGB Patch Embedding</span></span><br><span class="line">        <span class="comment"># 关键步骤1：RGB图像 (B, 3, 224, 224) -&gt; patch embedding</span></span><br><span class="line">        x = <span class="variable language_">self</span>.patch_embed(x)[<span class="number">0</span>]  <span class="comment"># 输出 (B, 196, 768)</span></span><br><span class="line">        <span class="comment"># 196 = (224/16) * (224/16) 个patch，768 是embedding维度</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加位置编码（不包含CLS token）</span></span><br><span class="line">        x = x + <span class="variable language_">self</span>.pos_embed[:, <span class="number">1</span>:, :]  <span class="comment"># (B, 196, 768)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Thermal Patch Embedding</span></span><br><span class="line">        <span class="comment"># 关键步骤2：Thermal图像 (B, 1, 224, 224) -&gt; patch embedding</span></span><br><span class="line">        x2 = <span class="variable language_">self</span>.patch_embed(x2)[<span class="number">0</span>]  <span class="comment"># 输出 (B, 196, 768)</span></span><br><span class="line">        <span class="comment"># 同一个patch_embed对象处理两个模态，但输入不同</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 添加位置编码（不包含CLS token）</span></span><br><span class="line">        x2 = x2 + <span class="variable language_">self</span>.pos_embed[:, <span class="number">1</span>:, :]  <span class="comment"># (B, 196, 768)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>GMM-CMSS 渐进式掩码策略</strong><br>基于跨模态结构稀疏性（CMSS）度量，动态决定不同模态、不同区域的掩码位置，实现模态平衡与由易到难的训练。<strong>这是相比MAE最重要的改进。</strong></p></li><li><p><strong>共享权重 Transformer 编码器</strong><br>未被掩码的 RGB &#x2F; Thermal token 输入同一个 ViT 编码器，促使两模态在潜在空间中对齐。共享权重避免引入模态特定的融合模块。</p></li><li><p><strong>双解码器 + 跨模态交互重建</strong><br>通过两个模态特定解码器分别重建 RGB 与热红外，被掩码区域的重建过程中引入跨模态注意力以利用互补信息。</p></li></ol><p>预训练完成后，仅保留 ViT 编码器作为通用特征提取 backbone，迁移到检测、分割、显著性检测和跟踪等下游任务。整个框架的设计遵循 <strong>“模态独立处理 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">⇒</span></span></span></span> 共享特征学习 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⇒</mo></mrow><annotation encoding="application/x-tex">\Rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.3669em"></span><span class="mrel">⇒</span></span></span></span> 模态特定重建”</strong> 的原则。</p><hr><h2 id="3-2-跨模态结构稀疏性（Cross-Modality-Structural-Sparsity-CMSS）"><a href="#3-2-跨模态结构稀疏性（Cross-Modality-Structural-Sparsity-CMSS）" class="headerlink" title="3.2 跨模态结构稀疏性（Cross-Modality Structural Sparsity, CMSS）"></a>3.2 跨模态结构稀疏性（Cross-Modality Structural Sparsity, CMSS）</h2><h3 id="3-2-1-设计原因"><a href="#3-2-1-设计原因" class="headerlink" title="3.2.1 设计原因"></a>3.2.1 设计原因</h3><p>RGBT 数据存在显著的 <strong>信息不平衡（information imbalance）</strong>：</p><ul><li>RGB 图像包含丰富的纹理、颜色与细节结构；</li><li>热红外图像通常更平滑，语义信息集中在目标轮廓和温度分布上。</li></ul><p>若在自监督预训练中对两模态采用<strong>相同的随机掩码策略</strong>，模型往往更容易依赖 RGB 模态，导致 <strong>模态偏置（modality bias）</strong>，热红外分支学习不足。</p><p>因此，需要一个能够<strong>量化 RGB–T 信息分布差异</strong>的度量，以指导信息感知的掩码策略。</p><hr><h3 id="3-2-2-CMSS-的实现"><a href="#3-2-2-CMSS-的实现" class="headerlink" title="3.2.2 CMSS 的实现"></a>3.2.2 CMSS 的实现</h3><p>这里需要强调的是，<strong>论文中的 CMSS 并非在像素空间定义</strong>，而是在 <strong>ViT patch embedding 空间</strong>，用于衡量 <strong>跨模态 patch 对的结构稀疏性 &#x2F; 信息密度</strong>。</p><p>对于一对 RGB–Thermal patch embedding <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo>∈</mo><msup><mi mathvariant="double-struck">R</mi><mn>768</mn></msup></mrow><annotation encoding="application/x-tex">a, b \in \mathbb{R}^{768}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord"><span class="mord mathbb">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">768</span></span></span></span></span></span></span></span></span></span></span></span>，CMSS 定义为：</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>CMSS</mtext><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mn>1</mn><mo>+</mo><mrow><mo fence="true">⟨</mo><mfrac><mi>a</mi><mrow><mi mathvariant="normal">∣</mi><mi>a</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo separator="true">,</mo><mfrac><mi>b</mi><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><mo fence="true">⟩</mo></mrow></mrow><mrow><mn>2</mn><mo>⋅</mo><msubsup><mi>σ</mi><mi>a</mi><mn>2</mn></msubsup><mo>⋅</mo><msubsup><mi>σ</mi><mi>b</mi><mn>2</mn></msubsup></mrow></mfrac></mrow><annotation encoding="application/x-tex">\text{CMSS}(a, b) = \frac{1 + \left\langle \frac{a}{|a|}, \frac{b}{|b|} \right\rangle} {2 \cdot \sigma_a^2 \cdot \sigma_b^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord text"><span class="mord">CMSS</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:3.1773em;vertical-align:-.9873em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.19em"><span style="top:-2.464em"><span class="pstrut" style="height:3.15em"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.7401em"><span style="top:-2.453em;margin-left:-.0359em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">a</span></span></span><span style="top:-2.989em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.247em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.7959em"><span style="top:-2.3987em;margin-left:-.0359em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span><span style="top:-3.0448em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.3013em"><span></span></span></span></span></span></span></span></span><span style="top:-3.38em"><span class="pstrut" style="height:3.15em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-4.19em"><span class="pstrut" style="height:3.15em"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size2">⟨</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.6954em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight">a</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.52em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8801em"><span style="top:-2.655em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∣</span><span class="mord mathnormal mtight">b</span><span class="mord mtight">∣</span></span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.394em"><span class="pstrut" style="height:3em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.52em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size2">⟩</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.9873em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><p>其中：</p><ul><li>分子为 RGB–T patch embedding 的 <strong>余弦相似度</strong>，捕捉两模态特征的对齐程度；</li><li>分母为两模态 embedding 的 <strong>结构方差（structural variance）</strong>，表示特征的多样性；</li><li>CMSS 最终被归一化到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 区间。</li></ul><blockquote><p>余弦相似度：</p><ul><li>两根箭头（向量）夹角是 θ</li><li>夹角的 <strong>cos(θ)</strong> 就能表示“方向的相似程度”</li></ul><p>余弦相似度的结果 <strong>一定在 -1 到 1 之间</strong>：</p><table><thead><tr><th>数值</th><th>含义</th></tr></thead><tbody><tr><td><strong>1</strong></td><td>几乎完全相同</td></tr><tr><td><strong>0</strong></td><td>互不相干</td></tr><tr><td><strong>-1</strong></td><td>完全相反</td></tr></tbody></table></blockquote><p><strong>实现代码</strong>（源自 <a href="M-SpecGene/pretrain/mmpretrain-main_rgbt/mmpretrain/models/selfsup/GMM_CMSS_SAMPLE.py">GMM_CMSS_SAMPLE.py</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">CMSS_Similarity</span>(<span class="params">self, tensor_1, tensor_2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算跨模态结构稀疏性度量 CMSS&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 归一化为单位向量，计算余弦相似度</span></span><br><span class="line">    normalized_tensor_1 = tensor_1 / tensor_1.norm(dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    normalized_tensor_2 = tensor_2 / tensor_2.norm(dim=-<span class="number">1</span>, keepdim=<span class="literal">True</span>)</span><br><span class="line">    r_num = torch.<span class="built_in">sum</span>(normalized_tensor_1 * normalized_tensor_2, dim=<span class="number">1</span>)</span><br><span class="line">    r_num = (r_num + <span class="number">1.0</span>) * <span class="number">0.5</span>  <span class="comment"># 映射到[0,1]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算结构方差</span></span><br><span class="line">    var_tensor_1 = torch.var(tensor_1, dim=<span class="number">1</span>)</span><br><span class="line">    var_tensor_2 = torch.var(tensor_2, dim=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># CMSS = sqrt(余弦相似度) / (var_rgb * var_thermal)</span></span><br><span class="line">    r_num = torch.sqrt(r_num)</span><br><span class="line">    measure = r_num / (var_tensor_1 * var_tensor_2 + <span class="number">1e-8</span>)</span><br><span class="line">    measure = measure / (torch.<span class="built_in">max</span>(measure) + <span class="number">1e-8</span>)</span><br><span class="line">    <span class="keyword">return</span> measure</span><br></pre></td></tr></table></figure><h4 id="CMSS-数值含义"><a href="#CMSS-数值含义" class="headerlink" title="CMSS 数值含义"></a>CMSS 数值含义</h4><ul><li><p><strong>CMSS 较大</strong>（接近1）：</p><ul><li>RGB–T patch embedding 相似度高</li><li>两模态方差都较小</li><li>对应 <strong>低信息密度 &#x2F; 背景区域</strong></li></ul></li><li><p><strong>CMSS 较小</strong>（接近0）：</p><ul><li>跨模态差异更明显</li><li>方差更大（特征变化丰富）</li><li>对应 <strong>高信息密度 &#x2F; 目标区域</strong></li></ul></li></ul><hr><h3 id="3-2-3-CMSS-的数据统计特性"><a href="#3-2-3-CMSS-的数据统计特性" class="headerlink" title="3.2.3 CMSS 的数据统计特性"></a>3.2.3 CMSS 的数据统计特性</h3><p>论文在 11 个 RGBT 数据集上统计了 CMSS 分布，发现：</p><ul><li>CMSS 呈现明显的 <strong>多峰分布</strong>，对应不同类型区域（目标 &#x2F; 背景）</li><li>不同数据集的 CMSS 分布存在显著差异，反映场景复杂度与成像条件差异</li><li>少量样本中，热红外在目标区域占主导，CMSS 值相对较低</li></ul><p>这一观察为后续采用概率建模而非固定规则的掩码策略提供了依据。在此基础上，论文引入高斯混合模型（GMM）对CMSS分布进行参数化建模，而非采用简单的阈值或固定比例。</p><hr><h2 id="3-3-GMM-CMSS-渐进式掩码"><a href="#3-3-GMM-CMSS-渐进式掩码" class="headerlink" title="3.3 GMM-CMSS 渐进式掩码"></a>3.3 GMM-CMSS 渐进式掩码</h2><h3 id="3-3-1-设计原则"><a href="#3-3-1-设计原则" class="headerlink" title="3.3.1 设计原则"></a>3.3.1 设计原则</h3><p>掩码策略需要同时满足三点：</p><ol><li><p><strong>模态平衡</strong><br>信息密度高的区域 &#x2F; 模态应更容易被掩码，防止模型产生偏置。</p></li><li><p><strong>由易到难</strong><br>训练初期关注高信息区域，后期逐渐覆盖低信息区域。</p></li><li><p><strong>目标中心</strong><br>优先保留语义丰富的目标区域，避免模型过多重建无意义背景。</p></li></ol><hr><h3 id="3-3-2-CMSS-的高斯混合建模（GMM）"><a href="#3-3-2-CMSS-的高斯混合建模（GMM）" class="headerlink" title="3.3.2 CMSS 的高斯混合建模（GMM）"></a>3.3.2 CMSS 的高斯混合建模（GMM）</h3><p><img data-src="/./../images/image-20251214121726437.png" alt="image-20251214121726437"></p><p>为了对 <strong>全数据集的 CMSS 分布</strong> 进行建模，论文采用 <strong>Gaussian Mixture Model (GMM)</strong> 对 CMSS 进行统计拟合：</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>p</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>π</mi><mi>k</mi></msub><mi mathvariant="script">N</mi><mo stretchy="false">(</mo><mi>m</mi><mo>∣</mo><msub><mi>μ</mi><mi>k</mi></msub><mo separator="true">,</mo><msub><mi mathvariant="normal">Σ</mi><mi>k</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">p(m) = \sum_{k=1}^{K} \pi_k \mathcal{N}(m \mid \mu_k, \Sigma_k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:3.1304em;vertical-align:-1.3021em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em"><span style="top:-1.8479em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:-.0359em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord mathcal" style="margin-right:.14736em">N</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal">μ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal">m</span></span></span></span> 表示 CMSS 值；</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">K=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">3</span></span></span></span> 表示三种典型信息密度模式；</li><li>GMM 参数通过迭代式 EM 算法在训练过程中动态更新。</li></ul><p><strong>GMM的EM算法实现（源自 <a href="M-SpecGene/pretrain/mmpretrain-main_rgbt/mmpretrain/models/selfsup/GMM_CMSS_SAMPLE.py">GMM_CMSS_SAMPLE.py</a>）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">e_step</span>(<span class="params">self, X</span>):  <span class="comment"># X: shape = (N,), 所有 patch 的 CMSS 值</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    E-step（期望步）：</span></span><br><span class="line"><span class="string">    在当前 GMM 参数（均值、方差、权重）下，</span></span><br><span class="line"><span class="string">    计算每个 CMSS 样本属于每个高斯分量的后验概率（责任度）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># resp: 责任度矩阵，shape = (N, K)</span></span><br><span class="line">    <span class="comment"># resp[n, k] 表示第 n 个 CMSS 值来自第 k 个高斯分量的概率</span></span><br><span class="line">    <span class="variable language_">self</span>.resp = np.zeros((X.shape[<span class="number">0</span>], <span class="variable language_">self</span>.n_components))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个高斯分量 k</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n_components):</span><br><span class="line">        <span class="comment"># 权重 × 高斯概率密度</span></span><br><span class="line">        <span class="comment"># 表示：在第 k 个高斯下生成 X 的“未归一化概率”</span></span><br><span class="line">        <span class="variable language_">self</span>.resp[:, k] = (</span><br><span class="line">            <span class="variable language_">self</span>.GMM_weights[k] *</span><br><span class="line">            <span class="variable language_">self</span>.gaussian(X, <span class="variable language_">self</span>.GMM_means[k], <span class="variable language_">self</span>.GMM_covariances[k])</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对每个样本，在 K 个高斯分量上做归一化</span></span><br><span class="line">    <span class="comment"># 保证：∑_k resp[n, k] = 1</span></span><br><span class="line">    <span class="variable language_">self</span>.resp = <span class="variable language_">self</span>.resp / <span class="variable language_">self</span>.resp.<span class="built_in">sum</span>(axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">m_step</span>(<span class="params">self, X</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    M-step（最大化步）：</span></span><br><span class="line"><span class="string">    固定 E-step 得到的责任度，</span></span><br><span class="line"><span class="string">    重新估计每个高斯分量的：</span></span><br><span class="line"><span class="string">    均值、方差、混合权重</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># N_k: 每个高斯分量“有效样本数”</span></span><br><span class="line">    <span class="comment"># 表示：这个高斯大概负责了多少数据</span></span><br><span class="line">    N_k = <span class="variable language_">self</span>.resp.<span class="built_in">sum</span>(axis=<span class="number">0</span>)  <span class="comment"># shape = (K,)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新均值 μ_k</span></span><br><span class="line">    <span class="comment"># 加权平均：责任度越高，贡献越大</span></span><br><span class="line">    <span class="variable language_">self</span>.GMM_means = (<span class="variable language_">self</span>.resp.T @ X) / N_k</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新方差 σ_k^2</span></span><br><span class="line">    <span class="comment"># 同样是加权的平方偏差</span></span><br><span class="line">    <span class="variable language_">self</span>.GMM_covariances = np.array([</span><br><span class="line">        np.<span class="built_in">sum</span>(<span class="variable language_">self</span>.resp[:, k] * (X - <span class="variable language_">self</span>.GMM_means[k])**<span class="number">2</span>) / N_k[k]</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.n_components)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新混合权重 π_k</span></span><br><span class="line">    <span class="comment"># 表示每个高斯在整体中占的比例</span></span><br><span class="line">    <span class="variable language_">self</span>.GMM_weights = N_k / X.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian</span>(<span class="params">self, X, mean, cov</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    一维高斯分布的概率密度函数</span></span><br><span class="line"><span class="string">    X: CMSS 值</span></span><br><span class="line"><span class="string">    mean: 高斯均值 μ</span></span><br><span class="line"><span class="string">    cov: 方差 σ^2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="number">1</span> / np.sqrt(<span class="number">2</span> * np.pi * cov) *</span><br><span class="line">        np.exp(-<span class="number">0.5</span> * ((X - mean) ** <span class="number">2</span> / cov))</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>需要注意，<strong>GMM 并不直接决定掩码位置</strong>，而是对CMSS分布的概率建模，为采样提供依据。</p><hr><h3 id="3-3-3-基于-GMM-的采样函数与渐进式掩码"><a href="#3-3-3-基于-GMM-的采样函数与渐进式掩码" class="headerlink" title="3.3.3 基于 GMM 的采样函数与渐进式掩码"></a>3.3.3 基于 GMM 的采样函数与渐进式掩码</h3><p>真正控制 <strong>哪些 patch 被 mask</strong> 的，是基于 GMM 构造的 <strong>采样函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></strong>：</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>K</mi></munderover><msub><mi>π</mi><mi>k</mi></msub><mi mathvariant="script">N</mi><mrow><mo fence="true">(</mo><mi>x</mi><mo>∣</mo><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mi>k</mi></msub><mo>+</mo><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mrow><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow></msub><mo separator="true">,</mo><msub><mover accent="true"><mi mathvariant="normal">Σ</mi><mo>^</mo></mover><mi>k</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">S(x)=\sum_{k=1}^{K} \pi_k \mathcal{N}\left(x \mid \hat{\mu}_k + \hat{\mu}_{bias}, \hat{\Sigma}_k \right)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:3.1304em;vertical-align:-1.3021em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em"><span style="top:-1.8479em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3021em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:-.0359em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord mathcal" style="margin-right:.14736em">N</span><span class="mspace" style="margin-right:.1667em"></span><span class="minner"><span class="mopen delimcenter" style="top:0"><span class="delimsizing size2">(</span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:.2778em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.6944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.2222em"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.6944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.2222em"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">bia</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.9468em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord">Σ</span></span><span style="top:-3.2523em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.25em"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0"><span class="delimsizing size2">)</span></span></span></span></span></span></span><p><strong>采样和掩码生成的核心逻辑</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sample</span>(<span class="params">self, x, x2, loss1, loss2, mask_ratio</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;基于GMM-CMSS策略生成两模态的动态掩码&quot;&quot;&quot;</span></span><br><span class="line">    N, L, D = x.shape</span><br><span class="line">    len_keep = <span class="built_in">int</span>(L * (<span class="number">1</span> - mask_ratio))  <span class="comment"># 保留约25%的patch</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. 计算CMSS：衡量RGB-Thermal的信息密度</span></span><br><span class="line">    msdi_value = <span class="variable language_">self</span>.CMSS_Similarity(x_flat, x2_flat)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. E步：计算CMSS属于各高斯分量的责任度</span></span><br><span class="line">    <span class="variable language_">self</span>.e_step(msdi_value.cpu().numpy())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. M步：动态更新GMM参数（均值、方差、权重）</span></span><br><span class="line">    <span class="variable language_">self</span>.m_step(msdi_value.cpu().numpy())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 针对Thermal模态采样（掩码比例较低以保留目标）</span></span><br><span class="line">    noise = <span class="variable language_">self</span>.generate_GMM_PDF(N, L, x, <span class="variable language_">self</span>.sample_gmm_bias)</span><br><span class="line">    len_keep1 = len_keep - <span class="built_in">int</span>(<span class="variable language_">self</span>.maskratio_bias)</span><br><span class="line">    ids_shuffle, _ = <span class="variable language_">self</span>.cal_ids_shuffle(noise, msdi_value, msdi_value2, x, len_keep1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 5. 生成Thermal掩码：0=保留, 1=掩码</span></span><br><span class="line">    mask = torch.ones([N, L], device=x.device)\n    mask[:, :len_keep1] = <span class="number">0</span></span><br><span class="line">    x_masked = torch.gather(x, dim=<span class="number">1</span>, index=ids_keep.unsqueeze(-<span class="number">1</span>).repeat(<span class="number">1</span>,<span class="number">1</span>,D))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 6. 针对RGB模态采样（掩码比例较高以学习补偿）</span></span><br><span class="line">    noise2 = <span class="variable language_">self</span>.generate_GMM_PDF(N, L, x2, -<span class="variable language_">self</span>.sample_gmm_bias)</span><br><span class="line">    len_keep2 = len_keep + <span class="built_in">int</span>(<span class="variable language_">self</span>.maskratio_bias)</span><br><span class="line">    ids_shuffle2 = <span class="variable language_">self</span>.cal_ids_shuffle(noise2, msdi_value2, msdi_value2, x, len_keep2)</span><br><span class="line">    <span class="comment"># ...... RGB掩码生成逻辑类似</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 7. 关键创新：根据损失和训练进度动态调整参数</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.count &gt; <span class="variable language_">self</span>.count_flag:  <span class="comment"># 每个epoch更新一次</span></span><br><span class="line">        delta_loss = loss2 - loss1  <span class="comment"># 两模态的损失差异</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果Thermal损失较大，增加它的掩码比例</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.maskratio_bias &lt; threshold:</span><br><span class="line">            <span class="variable language_">self</span>.maskratio_bias += delta_loss * <span class="number">10</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 逐步调整采样的偏移幅度</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.sample_gmm_bias &lt; <span class="variable language_">self</span>.sample_gmm_bias_max:</span><br><span class="line">            <span class="variable language_">self</span>.sample_gmm_bias += delta_loss * <span class="number">0.1</span></span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">self</span>.epoch += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x_masked, mask, ids_restore, x_masked2, mask2, ids_restore2</span><br></pre></td></tr></table></figure><p><strong>渐进式掩码策略的三个阶段</strong>：</p><ul><li><p><strong>训练初期</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>p</mi><mi>o</mi><mi>c</mi><mi>h</mi><mo>&lt;</mo><mi>e</mi><mi>p</mi><mi>o</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">epoch &lt; epoch\_num/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-.31em"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">h</span><span class="mord" style="margin-right:.02778em">_</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">/2</span></span></span></span>)：</p><ul><li><code>sample_gmm_bias</code> 逐步增加 → 采样逐步向低CMSS偏移</li><li>Thermal掩码比例↓，RGB掩码比例↑ → 保留目标，掩码背景</li><li>目的：帮助模型快速学到目标相关特征，建立两模态对齐</li></ul></li><li><p><strong>训练中期</strong>：</p><ul><li><code>sample_gmm_bias</code> 接近最大值 → 采样接近真实CMSS分布</li><li>两模态掩码比例趋于平衡 → 类似于标准MAE的随机掩码</li><li>目的：避免任何模态过度依赖，均衡学习</li></ul></li><li><p><strong>训练后期</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>p</mi><mi>o</mi><mi>c</mi><mi>h</mi><mo>≥</mo><mi>e</mi><mi>p</mi><mi>o</mi><mi>c</mi><mi>h</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">epoch \geq epoch\_num/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.06em;vertical-align:-.31em"></span><span class="mord mathnormal">e</span><span class="mord mathnormal">p</span><span class="mord mathnormal">oc</span><span class="mord mathnormal">h</span><span class="mord" style="margin-right:.02778em">_</span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord">/2</span></span></span></span>)：</p><ul><li><code>sample_gmm_bias</code> 保持最大值 → 采样向高CMSS区域偏移</li><li>Thermal掩码比例↑，RGB掩码比例↓ → 掩码更多目标，保留背景</li><li>目的：强化模型对互补信息的利用，学会在信息缺失时从另一模态推理</li></ul></li></ul><p>其核心思想为：</p><ul><li>训练初期：采样集中在 <strong>低 CMSS 区域（高信息密度）</strong> → 保留目标区域，降低重建难度</li><li>训练中期：采样逐渐逼近真实 CMSS 分布 → 类似随机掩码</li><li>训练后期：采样向 <strong>高 CMSS 区域（低信息密度）</strong> 偏移 → 强化模型对背景和模态互补的理解</li></ul><p>通过逐步调整 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\mu}_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.6944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.2222em"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.03148em">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>μ</mi><mo>^</mo></mover><mrow><mi>b</mi><mi>i</mi><mi>a</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\hat{\mu}_{bias}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8889em;vertical-align:-.1944em"></span><span class="mord"><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.6944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">μ</span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.2222em"><span class="mord">^</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.1944em"><span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">bia</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span>，实现 <strong>由易到难的渐进式自监督学习</strong>。</p><p><strong>核心创新点</strong>：不是固定的掩码比例（如MAE的0.75），而是基于CMSS和损失的<strong>自适应、动态、课程式</strong>掩码策略。</p><h2 id="3-4-Siamese-编码与跨模态重建"><a href="#3-4-Siamese-编码与跨模态重建" class="headerlink" title="3.4 Siamese 编码与跨模态重建"></a>3.4 Siamese 编码与跨模态重建</h2><h3 id="3-4-1-Siamese-编码器设计与双模态前向传播"><a href="#3-4-1-Siamese-编码器设计与双模态前向传播" class="headerlink" title="3.4.1 Siamese 编码器设计与双模态前向传播"></a>3.4.1 Siamese 编码器设计与双模态前向传播</h3><p>RGB 与热红外 token 经过共享权重的 ViT 编码器，强制两模态映射到统一潜在空间，避免引入额外的手工融合模块，有助于学习模态不变表示。</p><p><strong>双模态前向传播的实现</strong>（源自 <a href="M-SpecGene/pretrain/mmpretrain-main_rgbt/mmpretrain/models/selfsup/mae.py">mae.py</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, x2, loss1, loss2, mask=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;双模态MAE的前向传播过程</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x: RGB输入, shape (B, 3, 224, 224)</span></span><br><span class="line"><span class="string">        x2: Thermal输入, shape (B, 3, 224, 224)  # 单通道重复为3通道</span></span><br><span class="line"><span class="string">        loss1, loss2: 前一步的损失（用于动态掩码调整）</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        编码器输出和掩码信息（传递给解码器）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    B = x.shape[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. Patch Embedding：将图像分割为patch并线性投影</span></span><br><span class="line">    <span class="comment"># RGB：(B, 3, 224, 224) -&gt; (B, 196, 768) [16x16 patch, 196 patches]</span></span><br><span class="line">    x = <span class="variable language_">self</span>.patch_embed(x)[<span class="number">0</span>]  </span><br><span class="line">    x = x + <span class="variable language_">self</span>.pos_embed[:, <span class="number">1</span>:, :]  <span class="comment"># 加位置编码（不包含CLS token）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Thermal：同样处理</span></span><br><span class="line">    x2 = <span class="variable language_">self</span>.patch_embed(x2)[<span class="number">0</span>]</span><br><span class="line">    x2 = x2 + <span class="variable language_">self</span>.pos_embed[:, <span class="number">1</span>:, :]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 创新：GMM-CMSS动态掩码策略</span></span><br><span class="line">    <span class="comment"># 不是简单的随机掩码，而是基于跨模态结构稀疏性和损失的自适应掩码</span></span><br><span class="line">    x, mask, ids_restore, x2, mask2, ids_restore2 = <span class="variable language_">self</span>.random_masking(</span><br><span class="line">        x, x2, loss1, loss2, <span class="variable language_">self</span>.mask_ratio</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># 输出：</span></span><br><span class="line">    <span class="comment"># - x: 被掩码后的RGB tokens (B, 49, 768) # 25%的patch</span></span><br><span class="line">    <span class="comment"># - mask: 掩码指示 (B, 196) # 0=keep, 1=mask</span></span><br><span class="line">    <span class="comment"># - ids_restore: 用于恢复原始顺序</span></span><br><span class="line">    <span class="comment"># - x2, mask2, ids_restore2: Thermal对应的输出</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 添加CLS token并进行Transformer编码</span></span><br><span class="line">    <span class="comment"># CLS token初始为学习参数，添加位置编码</span></span><br><span class="line">    cls_token = <span class="variable language_">self</span>.cls_token + <span class="variable language_">self</span>.pos_embed[:, :<span class="number">1</span>, :]</span><br><span class="line">    cls_tokens = cls_token.expand(B, -<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment"># (B, 1, 768)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># RGB分支：[CLS] + 可见的RGB tokens</span></span><br><span class="line">    x = torch.cat((cls_tokens, x), dim=<span class="number">1</span>)  <span class="comment"># (B, 50, 768)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Transformer编码：12层自注意力</span></span><br><span class="line">    <span class="keyword">for</span> _, layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.layers):</span><br><span class="line">        x = layer(x)  <span class="comment"># 自注意力在所有层间进行跨patch建模</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 最后一层归一化</span></span><br><span class="line">    x = <span class="variable language_">self</span>.norm1(x)  <span class="comment"># (B, 50, 768)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Thermal分支：[CLS] + 可见的Thermal tokens</span></span><br><span class="line">    <span class="comment"># 关键：RGB和Thermal共享同一个编码器权重</span></span><br><span class="line">    <span class="comment"># 这强制两模态学到对齐的表示</span></span><br><span class="line">    x2 = torch.cat((cls_tokens, x2), dim=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> _, layer <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="variable language_">self</span>.layers):</span><br><span class="line">        x2 = layer(x2)  <span class="comment"># 使用同样的Transformer层</span></span><br><span class="line">    x2 = <span class="variable language_">self</span>.norm1(x2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x, mask, ids_restore, x2, mask2, ids_restore2</span><br></pre></td></tr></table></figure><p><strong>关键设计点</strong>：</p><ol><li><p><strong>共享权重的编码器</strong>：RGB和Thermal使用完全相同的Transformer参数</p><ul><li>优点：强制跨模态对齐，减少参数数量</li><li>避免模态特定的手工融合模块</li></ul></li><li><p><strong>分离的掩码策略</strong>：RGB和Thermal有不同的掩码比例</p><ul><li>RGB：掩码比例较高（如0.8），强制学习互补信息</li><li>Thermal：掩码比例较低（如0.7），保留更多目标信息</li></ul></li></ol><hr><h3 id="3-4-2-跨模态解码与重建"><a href="#3-4-2-跨模态解码与重建" class="headerlink" title="3.4.2 跨模态解码与重建"></a>3.4.2 跨模态解码与重建</h3><p>在解码阶段，模型采用：</p><ul><li><strong>两个模态特定解码器</strong>（RGB &#x2F; Thermal）</li><li>解码过程中引入 <strong>跨模态注意力（cross-attention）</strong></li></ul><p>其作用并非强制特征融合，而是在重建被掩码区域时，允许模型利用另一模态的互补信息。</p><p>这种设计既保留了 Siamese 编码的对称性，又避免在编码阶段引入新的模态偏置。</p><p><strong>双模态损失计算</strong>（源自 MAE类的 <code>loss()</code> 方法）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, inputs, data_samples, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算RGB和Thermal的重建损失&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 分离输入：(B, 6, 224, 224) -&gt; (B, 3, 224, 224) x 2</span></span><br><span class="line">    input_rgb = inputs[:, <span class="number">0</span>:<span class="number">3</span>, :, :]</span><br><span class="line">    input_ir = inputs[:, <span class="number">3</span>:<span class="number">6</span>, :, :]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 前向传播获得编码器输出和掩码</span></span><br><span class="line">    latent, mask, ids_restore, latent2, mask2, ids_restore2 = <span class="variable language_">self</span>.backbone(</span><br><span class="line">        input_rgb, input_ir, <span class="variable language_">self</span>.loss1, <span class="variable language_">self</span>.loss2</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解码并重建RGB和Thermal</span></span><br><span class="line">    pred, pred2 = <span class="variable language_">self</span>.neck(latent, ids_restore, latent2, ids_restore2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># **关键**：只计算被掩码区域的重建损失</span></span><br><span class="line">    <span class="comment"># 这强制模型学会从可见tokens推理被掩码的像素</span></span><br><span class="line">    loss_rgb = <span class="variable language_">self</span>.head.loss(pred, input_rgb, mask)    <span class="comment"># RGB重建损失</span></span><br><span class="line">    loss_ir = <span class="variable language_">self</span>.head.loss(pred2, input_ir, mask2)    <span class="comment"># Thermal重建损失</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 存储损失用于下一步掩码调整</span></span><br><span class="line">    <span class="variable language_">self</span>.loss1 = loss_rgb</span><br><span class="line">    <span class="variable language_">self</span>.loss2 = loss_ir</span><br><span class="line">    </span><br><span class="line">    losses = <span class="built_in">dict</span>(loss=loss_rgb, loss2=loss_ir)</span><br><span class="line">    <span class="keyword">return</span> losses</span><br></pre></td></tr></table></figure><p><strong>损失函数设计的妙处</strong>：</p><ol><li><strong>只掩码区域的损失</strong>：不计算保留token的重建误差，避免浪费计算</li><li><strong>独立的模态损失</strong>：RGB和Thermal的重建目标独立，避免交叉干扰</li><li><strong>损失差异驱动适应</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi><mo>=</mo><mi>L</mi><mi>o</mi><mi>s</mi><msub><mi>s</mi><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>−</mo><mi>L</mi><mi>o</mi><mi>s</mi><msub><mi>s</mi><mrow><mi>R</mi><mi>G</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Delta Loss = Loss_{Thermal} - Loss_{RGB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord">Δ</span><span class="mord mathnormal">L</span><span class="mord mathnormal">oss</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">os</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3361em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight" style="margin-right:.02778em">er</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord mathnormal">L</span><span class="mord mathnormal">os</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05017em">RGB</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 用于下一步动态调整掩码，实现自适应平衡</li></ol><hr><h2 id="3-5-预训练目标函数"><a href="#3-5-预训练目标函数" class="headerlink" title="3.5 预训练目标函数"></a>3.5 预训练目标函数</h2><h3 id="3-5-1-掩码图像建模（MIM）"><a href="#3-5-1-掩码图像建模（MIM）" class="headerlink" title="3.5.1 掩码图像建模（MIM）"></a>3.5.1 掩码图像建模（MIM）</h3><p>采用归一化像素重建作为主要自监督目标，遵循 MAE 的设计：</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">L</mi><mrow><mi>M</mi><mi>I</mi><mi>M</mi></mrow></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">M</mi><mi mathvariant="normal">∣</mi></mrow></mfrac><munder><mo>∑</mo><mrow><mi>i</mi><mo>∈</mo><mi mathvariant="script">M</mi></mrow></munder><mi mathvariant="normal">∣</mi><msub><mover accent="true"><mi>x</mi><mo>^</mo></mover><mi>i</mi></msub><mo>−</mo><msub><mi>x</mi><mi>i</mi></msub><msubsup><mi mathvariant="normal">∣</mi><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">\mathcal{L}_{MIM} = \frac{1}{|\mathcal{M}|} \sum_{i \in \mathcal{M}} |\hat{x}_i - x_i|_2^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mord mathnormal mtight" style="margin-right:.07847em">I</span><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:2.6431em;vertical-align:-1.3217em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">∣</span><span class="mord mathcal">M</span><span class="mord">∣</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.936em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em"><span style="top:-1.8557em;margin-left:0"><span class="pstrut" style="height:3.05em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight">M</span></span></span></span><span style="top:-3.05em"><span class="pstrut" style="height:3.05em"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.3217em"><span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">∣</span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">x</span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.2222em"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1.1141em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.8641em"><span style="top:-2.453em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.113em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.247em"><span></span></span></span></span></span></span></span></span></span></span><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="script">M</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\mathcal{M}|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord">∣</span><span class="mord mathcal">M</span><span class="mord">∣</span></span></span></span> 表示掩码区域的 patch 数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mover accent="true"><mi>x</mi><mo>^</mo></mover><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\hat{x}_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8444em;vertical-align:-.15em"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.6944em"><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="mord mathnormal">x</span></span><span style="top:-3em"><span class="pstrut" style="height:3em"></span><span class="accent-body" style="left:-.2222em"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 分别为重建和原始图像。这种设计的优点是：</p><ul><li><strong>简洁有效</strong>：直接优化像素重建，避免中间特征的额外假设</li><li><strong>模态不可知</strong>：RGB和Thermal都用相同的损失，避免模态特定设计</li><li><strong>只掩码区域优化</strong>：降低计算量，避免浪费在显然正确的可见区域</li></ul><hr><h3 id="3-5-2-跨模态对比约束（辅助损失）"><a href="#3-5-2-跨模态对比约束（辅助损失）" class="headerlink" title="3.5.2 跨模态对比约束（辅助损失）"></a>3.5.2 跨模态对比约束（辅助损失）</h3><p>为增强跨模态语义一致性，论文引入全局表示的对比损失（作为可选项）：</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi mathvariant="script">L</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub><mo>=</mo><mo>−</mo><mi>log</mi><mo>⁡</mo><mfrac><mrow><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>sim</mtext><mo stretchy="false">(</mo><msub><mi>z</mi><mrow><mi>R</mi><mi>G</mi><mi>B</mi></mrow></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>T</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>τ</mi><mo stretchy="false">)</mo></mrow><mrow><munder><mo>∑</mo><mi>j</mi></munder><mi>exp</mi><mo>⁡</mo><mo stretchy="false">(</mo><mtext>sim</mtext><mo stretchy="false">(</mo><msub><mi>z</mi><mrow><mi>R</mi><mi>G</mi><mi>B</mi></mrow></msub><mo separator="true">,</mo><msub><mi>z</mi><mi>j</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mi>τ</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">\mathcal{L}_{contrast} = -\log \frac{ \exp(\text{sim}(z_{RGB}, z_T)/\tau) }{ \sum_j \exp(\text{sim}(z_{RGB}, z_j)/\tau) }</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2806em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:2.5488em;vertical-align:-1.1218em"></span><span class="mord">−</span><span class="mspace" style="margin-right:.1667em"></span><span class="mop">lo<span style="margin-right:.01389em">g</span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em"><span style="top:-2.314em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.162em"><span style="top:-2.4003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.4358em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.1667em"></span><span class="mop">exp</span><span class="mopen">(</span><span class="mord text"><span class="mord">sim</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:-.044em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05017em">RGB</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3117em"><span style="top:-2.55em;margin-left:-.044em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2861em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.1132em">τ</span><span class="mclose">)</span></span></span><span style="top:-3.23em"><span class="pstrut" style="height:3em"></span><span class="frac-line" style="border-bottom-width:.04em"></span></span><span style="top:-3.677em"><span class="pstrut" style="height:3em"></span><span class="mord"><span class="mop">exp</span><span class="mopen">(</span><span class="mord text"><span class="mord">sim</span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:-.044em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05017em">RGB</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:-.044em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:.1132em">τ</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.1218em"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mrow><mi>R</mi><mi>G</mi><mi>B</mi></mrow></msub></mrow><annotation encoding="application/x-tex">z_{RGB}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:-.044em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05017em">RGB</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>z</mi><mi>T</mi></msub></mrow><annotation encoding="application/x-tex">z_T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.5806em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.04398em">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:-.044em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span> 为两模态编码器的全局 CLS token，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi></mrow><annotation encoding="application/x-tex">\tau</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.4306em"></span><span class="mord mathnormal" style="margin-right:.1132em">τ</span></span></span></span> 是温度参数。这个对比损失促进 RGB 和 Thermal 在特征空间中更加接近。</p><hr><h3 id="3-5-3-总体损失函数"><a href="#3-5-3-总体损失函数" class="headerlink" title="3.5.3 总体损失函数"></a>3.5.3 总体损失函数</h3><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">L</mi><mo>=</mo><msub><mi mathvariant="script">L</mi><mrow><mi>M</mi><mi>I</mi><mi>M</mi></mrow></msub><mo>+</mo><mi>λ</mi><msub><mi mathvariant="script">L</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>a</mi><mi>s</mi><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\mathcal{L} = \mathcal{L}_{MIM} + \lambda \mathcal{L}_{contrast}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6833em"></span><span class="mord mathcal">L</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8333em;vertical-align:-.15em"></span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3283em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span><span class="mord mathnormal mtight" style="margin-right:.07847em">I</span><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8444em;vertical-align:-.15em"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathcal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.2806em"><span style="top:-2.55em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:.02778em">r</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">s</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></span><p>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mn>0.1</mn></mrow><annotation encoding="application/x-tex">\lambda = 0.1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6944em"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0.1</span></span></span></span>，控制对比损失的权重。消融实验表明，对比损失对于密集预测任务（分割）和序列任务（跟踪）尤为重要。</p><p><strong>预训练过程的完整流程</strong>：</p><ol><li><strong>前向传播</strong>：输入RGB和Thermal → 动态掩码 → Transformer编码 → 双解码器重建</li><li><strong>损失计算</strong>：分别计算RGB和Thermal的MIM损失，以及全局的对比损失</li><li><strong>反向传播</strong>：损失反向传播更新所有参数（除去位置编码）</li><li><strong>掩码调整</strong>：根据两模态的损失差异，在下一个epoch调整掩码策略的参数</li><li><strong>迭代</strong>：重复上述过程800个epoch</li></ol><p>这种设计的创新之处在于：<strong>掩码策略不是预先固定，而是根据训练动态自适应调整</strong>。</p><hr><h2 id="3-6-下游任务中的特征融合策略"><a href="#3-6-下游任务中的特征融合策略" class="headerlink" title="3.6 下游任务中的特征融合策略"></a>3.6 下游任务中的特征融合策略</h2><p>M-SpecGene 在下游任务中采用<strong>双模态独立提取 + 早期融合</strong>的融合策略，避免引入复杂的任务特定融合模块。</p><h3 id="3-6-1-交叉注意力"><a href="#3-6-1-交叉注意力" class="headerlink" title="3.6.1 交叉注意力"></a>3.6.1 交叉注意力</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cross_attention3.py 第 184-268 行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, k=<span class="literal">None</span>, v=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        x: 查询 (RGB), shape (B, N, embed_dims)</span></span><br><span class="line"><span class="string">        k: 键 (Thermal), shape (B, N_k, embed_dims)  </span></span><br><span class="line"><span class="string">        v: 值 (Thermal), shape (B, N_v, embed_dims)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        融合特征 shape (B, N, embed_dims)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 步骤1：将RGB投影为查询Q，Thermal投影为键K</span></span><br><span class="line">    q = F.linear(<span class="built_in">input</span>=x, weight=<span class="variable language_">self</span>.q.weight, bias=<span class="literal">None</span>)      <span class="comment"># (B, N, 256)</span></span><br><span class="line">    k = F.linear(<span class="built_in">input</span>=k, weight=<span class="variable language_">self</span>.k.weight, bias=<span class="literal">None</span>)      <span class="comment"># (B, N, 256)</span></span><br><span class="line">    v = v  <span class="comment"># 值直接使用原始Thermal特征</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤2：L2归一化（重点！与标准Transformer不同）</span></span><br><span class="line">    q = torch.nn.functional.normalize(q, dim=-<span class="number">1</span>)</span><br><span class="line">    k = torch.nn.functional.normalize(k, dim=-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤3：Reshape为多头格式</span></span><br><span class="line">    q = q.reshape(B, N, <span class="number">1</span>, num_heads, -<span class="number">1</span>).permute(...)   <span class="comment"># (B, num_heads, N, dim)</span></span><br><span class="line">    k = k.reshape(B, N_k, <span class="number">1</span>, num_heads, -<span class="number">1</span>).permute(...)  <span class="comment"># (B, num_heads, N_k, dim)</span></span><br><span class="line">    v = v.reshape(B, N_v, <span class="number">1</span>, num_heads, -<span class="number">1</span>).permute(...)  <span class="comment"># (B, num_heads, N_v, dim)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤4：计算注意力权重</span></span><br><span class="line">    q = q * <span class="variable language_">self</span>.scale  <span class="comment"># 缩放因子 = 1/sqrt(dim)</span></span><br><span class="line">    attn = (q @ k.transpose(-<span class="number">2</span>, -<span class="number">1</span>))  <span class="comment"># (B, num_heads, N, N_k)</span></span><br><span class="line">    attn = attn.softmax(dim=-<span class="number">1</span>)        <span class="comment"># 沿着K维度softmax</span></span><br><span class="line">    attn = <span class="variable language_">self</span>.attn_drop(attn)        <span class="comment"># 注意力dropout</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 步骤5：加权求和得到融合特征</span></span><br><span class="line">    x = (attn @ v).transpose(<span class="number">1</span>, <span class="number">2</span>).reshape(B, N, -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x  <span class="comment"># 融合的RGB特征</span></span><br></pre></td></tr></table></figure><h3 id="3-6-2-融合的核心原理"><a href="#3-6-2-融合的核心原理" class="headerlink" title="3.6.2 融合的核心原理"></a>3.6.2 融合的核心原理</h3><p>预训练阶段学习了对齐的 RGB 和 Thermal 表示，在下游任务推理时：</p><ol><li><p><strong>RGB 和 Thermal 通过共享主干</strong>（预训练的 ViT-Base）<strong>独立提取特征</strong></p><ul><li>每个模态进行各自的 Patch Embedding 和 Transformer 编码</li><li>得到 4 个不同尺度的特征（FPN）：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>C</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>C</mi><mn>4</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mn>256</mn><mo separator="true">,</mo><mn>512</mn><mo separator="true">,</mo><mn>1024</mn><mo separator="true">,</mo><mn>2048</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(C_1, C_2, C_3, C_4) = (256, 512, 1024, 2048)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.3011em"><span style="top:-2.55em;margin-left:-.0715em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">256</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">512</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">1024</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2048</span><span class="mclose">)</span></span></span></span></li></ul></li><li><p><strong>逐级特征相加（Element-wise Addition）</strong><br>最简洁的融合方式是在每个尺度直接相加：</p></li></ol><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msubsup><mi mathvariant="bold">F</mi><mrow><mi>f</mi><mi>u</mi><mi>s</mi><mi>e</mi><mi>d</mi></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>=</mo><msubsup><mi mathvariant="bold">F</mi><mrow><mi>R</mi><mi>G</mi><mi>B</mi></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo>+</mo><msubsup><mi mathvariant="bold">F</mi><mrow><mi>T</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>a</mi><mi>l</mi></mrow><mrow><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow></msubsup><mo separator="true">,</mo><mspace width="1em"><mi>i</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\mathbf{F}_{fused}^{(i)} = \mathbf{F}_{RGB}^{(i)} + \mathbf{F}_{Thermal}^{(i)}, \quad i=1,2,3,4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4822em;vertical-align:-.4374em"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.3987em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.10764em">f</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">se</span><span class="mord mathnormal mtight">d</span></span></span></span><span style="top:-3.2198em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.4374em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:1.3383em;vertical-align:-.2935em"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.4065em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05017em">RGB</span></span></span></span><span style="top:-3.2198em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.2935em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:1.3461em;vertical-align:-.3013em"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0448em"><span style="top:-2.3987em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.13889em">T</span><span class="mord mathnormal mtight">h</span><span class="mord mathnormal mtight" style="margin-right:.02778em">er</span><span class="mord mathnormal mtight">ma</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span></span></span></span><span style="top:-3.2198em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.3013em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:1em"></span><span class="mspace" style="margin-right:.1667em"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2778em"></span></span><span class="base"><span class="strut" style="height:.8389em;vertical-align:-.1944em"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.1667em"></span><span class="mord">4</span></span></span></span></span><p><strong>代码实现</strong>（源自 <a href="M-SpecGene/seg/mmsegmentation-main-rgbt/mmseg/models/segmentors/encoder_decoder_concat.py">encoder_decoder_concat.py</a>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encode_decode</span>(<span class="params">self, inputs: Tensor, batch_img_metas: <span class="type">List</span>[<span class="built_in">dict</span>]</span>) -&gt; Tensor:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;下游任务推理时的融合前向传播&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># inputs shape: (B, 6, 224, 224) # 前3通道RGB，后3通道Thermal</span></span><br><span class="line">    input_rgb = inputs[:, <span class="number">0</span>:<span class="number">3</span>, :, :]    <span class="comment"># (B, 3, 224, 224)</span></span><br><span class="line">    input_ir = inputs[:, <span class="number">3</span>:<span class="number">6</span>, :, :]     <span class="comment"># (B, 3, 224, 224)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 1. RGB和Thermal分别通过预训练的ViT骨干提取多尺度特征</span></span><br><span class="line">    <span class="comment"># 返回4个特征图：stage0, stage1, stage2, stage3 (从浅到深)</span></span><br><span class="line">    x_rgb = <span class="variable language_">self</span>.extract_feat(input_rgb)   <span class="comment"># (B, 256, H/4, W/4), ... , (B, 2048, H/32, W/32)</span></span><br><span class="line">    x_ir = <span class="variable language_">self</span>.extract_feat(input_ir)     <span class="comment"># 同样的分辨率和通道数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 2. 融合：逐级相加</span></span><br><span class="line">    <span class="comment"># 对齐表示</span></span><br><span class="line">    x_stage0 = x_rgb[<span class="number">0</span>] + x_ir[<span class="number">0</span>]   <span class="comment"># (B, 256, H/4, W/4)</span></span><br><span class="line">    x_stage1 = x_rgb[<span class="number">1</span>] + x_ir[<span class="number">1</span>]   <span class="comment"># (B, 512, H/8, W/8)</span></span><br><span class="line">    x_stage2 = x_rgb[<span class="number">2</span>] + x_ir[<span class="number">2</span>]   <span class="comment"># (B, 1024, H/16, W/16)</span></span><br><span class="line">    x_stage3 = x_rgb[<span class="number">3</span>] + x_ir[<span class="number">3</span>]   <span class="comment"># (B, 2048, H/32, W/32)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 3. 融合特征组成特征金字塔，输入到任务特定的解码头</span></span><br><span class="line">    x_fused = (x_stage0, x_stage1, x_stage2, x_stage3)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. UperNet（分割）/ FPN (检测) / 其他解码头处理融合特征</span></span><br><span class="line">    seg_logits = <span class="variable language_">self</span>.decode_head(x_fused)  <span class="comment"># 返回分割图</span></span><br><span class="line">    <span class="keyword">return</span> seg_logits</span><br></pre></td></tr></table></figure><h3 id="3-6-3-为什么采用简单相加融合？"><a href="#3-6-3-为什么采用简单相加融合？" class="headerlink" title="3.6.3 为什么采用简单相加融合？"></a>3.6.3 为什么采用简单相加融合？</h3><p><strong>M-SpecGene 采用相加的原因</strong>：</p><ol><li><strong>预训练已完成对齐</strong>：共享编码器强制两模态学到对齐表示，下游任务无需再次对齐</li><li><strong>参数高效</strong>：无需引入新参数，避免下游任务过拟合（尤其在数据有限时）</li><li><strong>计算高效</strong>：单个加法操作，推理延迟最小</li><li><strong>理论简洁</strong>：直接加法体现了两模态的等价性，符合”通用表示”的设计哲学</li></ol><p><strong>实验验证</strong>：消融实验表明，相加融合与更复杂的注意力融合性能相当（仅差 0.2-0.5%），但参数减少 15-20%。</p><h2 id="3-7-方法的创新总结"><a href="#3-7-方法的创新总结" class="headerlink" title="3.7 方法的创新总结"></a>3.7 方法的创新总结</h2><p>相比标准 MAE，M-SpecGene 在RGBT预训练中的核心创新包括：</p><table><thead><tr><th>方面</th><th>标准MAE</th><th>M-SpecGene</th></tr></thead><tbody><tr><td><strong>掩码策略</strong></td><td>固定随机掩码（75%）</td><td>动态自适应掩码（基于CMSS和损失）</td></tr><tr><td><strong>模态处理</strong></td><td>单模态</td><td>双模态独立处理，编码器共享</td></tr><tr><td><strong>掩码动态调整</strong></td><td>无</td><td>根据Thermal&#x2F;RGB损失差异实时调整</td></tr><tr><td><strong>课程学习</strong></td><td>无</td><td>由易到难的渐进式掩码策略</td></tr><tr><td><strong>信息密度感知</strong></td><td>无</td><td>CMSS度量定量化模态差异</td></tr><tr><td><strong>模态平衡</strong></td><td>无</td><td>针对性的掩码比例差异</td></tr></tbody></table><h1 id="4-实验设置"><a href="#4-实验设置" class="headerlink" title="4. 实验设置"></a>4. 实验设置</h1><p>本节详细介绍了 M-SpecGene 的预训练和下游任务的实验配置，旨在充分验证方法的有效性和泛化能力。</p><h2 id="4-1-预训练数据与模型配置"><a href="#4-1-预训练数据与模型配置" class="headerlink" title="4.1 预训练数据与模型配置"></a>4.1 预训练数据与模型配置</h2><p><strong>预训练数据集</strong>：从多个 RGBT 数据集中收集图像对，构建大规模预训练数据：</p><ul><li><strong>数据集来源</strong>：KAIST、FLIR、LLVIP、M3FD、VEDAI 等 11 个公开数据集</li><li><strong>总样本量</strong>：约 <strong>150K 图像对</strong>（相比 ImageNet 的 1.2M 仍较小，但通过高效策略充分利用）</li><li><strong>分辨率</strong>：统一 resize 为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>224</mn><mo>×</mo><mn>224</mn></mrow><annotation encoding="application/x-tex">224 \times 224</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">224</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">224</span></span></span></span></li><li><strong>数据增强</strong>：随机裁剪、翻转、颜色抖动（仅RGB，保留Thermal物理特性）</li></ul><p>虽然数据量有限，但通过 GMM-CMSS 的高效掩码策略，模型能够充分利用这些数据。消融实验表明，即使仅用 25% 的数据（37K样本），M-SpecGene 仍能超越从零开始训练。</p><p><strong>模型架构</strong>：</p><ul><li><strong>主骨干</strong>：Vision Transformer (ViT) Base<ul><li>层数：12 层 Transformer 块</li><li>隐藏维度：768</li><li>注意力头数：12</li></ul></li><li><strong>Patch 大小</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mo>×</mo><mn>16</mn></mrow><annotation encoding="application/x-tex">16 \times 16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">16</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">16</span></span></span></span>（得到 196 个 patch）</li><li><strong>位置编码</strong>：固定 sine-cosine 位置编码（不可学习）</li></ul><p><strong>优化器配置</strong>：</p><ul><li><strong>优化器</strong>：AdamW</li><li><strong>学习率</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.5</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1.5 \times 10^{-4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1.5</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>（cosine schedule，10 epoch warmup）</li><li><strong>权重衰减</strong>：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.05</mn></mrow><annotation encoding="application/x-tex">0.05</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.6444em"></span><span class="mord">0.05</span></span></span></span></li><li><strong>Batch size</strong>：1024（8 卡 V100，分布式训练）</li><li><strong>训练 epoch</strong>：800（约 120 小时）</li></ul><hr><h2 id="4-2-下游任务与微调方案"><a href="#4-2-下游任务与微调方案" class="headerlink" title="4.2 下游任务与微调方案"></a>4.2 下游任务与微调方案</h2><p>评估 M-SpecGene 在四类代表性 RGBT 任务上的迁移性能：</p><h3 id="4-2-1-RGBT-目标检测"><a href="#4-2-1-RGBT-目标检测" class="headerlink" title="4.2.1 RGBT 目标检测"></a>4.2.1 RGBT 目标检测</h3><ul><li><strong>数据集</strong>：KAIST（95K 对）、FLIR（9K 对）、M3FD</li><li><strong>评估指标</strong>：Average Precision (AP)、Missing Rate (MR)</li><li><strong>微调策略</strong>：<ul><li>Faster R-CNN &#x2F; DETR 检测头</li><li>冻结位置编码，更新 Transformer 和检测头</li><li>50 epoch，学习率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1 \times 10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></li></ul></li></ul><h3 id="4-2-2-RGBT-语义分割"><a href="#4-2-2-RGBT-语义分割" class="headerlink" title="4.2.2 RGBT 语义分割"></a>4.2.2 RGBT 语义分割</h3><ul><li><strong>数据集</strong>：MFNet（城市）、PST900（室内）</li><li><strong>评估指标</strong>：mIoU（mean Intersection over Union）</li><li><strong>微调策略</strong>：<ul><li>UperNet 分割解码头</li><li>80 epoch，学习率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>4</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1 \times 10^{-4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span>，warmup 10 epoch</li></ul></li></ul><h3 id="4-2-3-RGBT-显著性检测"><a href="#4-2-3-RGBT-显著性检测" class="headerlink" title="4.2.3 RGBT 显著性检测"></a>4.2.3 RGBT 显著性检测</h3><ul><li><strong>数据集</strong>：VT821、VT1000、VT5000</li><li><strong>评估指标</strong>：F-measure、MAE、S-measure</li><li><strong>微调策略</strong>：全卷积解码器，40 epoch，学习率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">5 \times 10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">5</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><h3 id="4-2-4-RGBT-目标跟踪"><a href="#4-2-4-RGBT-目标跟踪" class="headerlink" title="4.2.4 RGBT 目标跟踪"></a>4.2.4 RGBT 目标跟踪</h3><ul><li><strong>数据集</strong>：RGBT234（234 个视频）、LasHeR（1,224 个视频）</li><li><strong>评估指标</strong>：Success Rate、Precision</li><li><strong>微调策略</strong>：Siamese 网络框架，30 epoch，学习率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>5</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1 \times 10^{-5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.7278em;vertical-align:-.0833em"></span><span class="mord">1</span><span class="mspace" style="margin-right:.2222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222em"></span></span><span class="base"><span class="strut" style="height:.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><hr><h2 id="4-3-对比基线"><a href="#4-3-对比基线" class="headerlink" title="4.3 对比基线"></a>4.3 对比基线</h2><p>为了全面验证 M-SpecGene 的贡献，设计了多个消融基线：</p><table><thead><tr><th>基线</th><th>说明</th><th>目的</th></tr></thead><tbody><tr><td><strong>从头训练</strong></td><td>不使用任何预训练</td><td>验证预训练的必要性</td></tr><tr><td><strong>ImageNet 预训练</strong></td><td>ViT-B on ImageNet（仅初始化RGB）</td><td>对比单模态预训练的局限</td></tr><tr><td><strong>单模态 MAE</strong></td><td>分别在RGB和Thermal上独立MAE预训练</td><td>验证是否需要双模态预训练</td></tr><tr><td><strong>RGBT 联合 MAE</strong></td><td>相同掩码比例的简单RGBT MAE</td><td>对比GMM-CMSS的必要性</td></tr><tr><td><strong>任务特定 SOTA</strong></td><td>各下游任务的当前最佳方法</td><td>验证通用预训练能否超越定制设计</td></tr></tbody></table><hr><h1 id="5-实验结果与分析"><a href="#5-实验结果与分析" class="headerlink" title="5. 实验结果与分析"></a>5. 实验结果与分析</h1><h2 id="5-1-下游任务整体性能"><a href="#5-1-下游任务整体性能" class="headerlink" title="5.1 下游任务整体性能"></a>5.1 下游任务整体性能</h2><h3 id="5-1-1-RGBT目标检测"><a href="#5-1-1-RGBT目标检测" class="headerlink" title="5.1.1 RGBT目标检测"></a>5.1.1 RGBT目标检测</h3><p><img data-src="/./../images/image-20251214105659860.png" alt="image-20251214105659860"></p><p>在KAIST数据集上：</p><ul><li>M-SpecGene达到 <strong>mAP 83.7%</strong>，超过任务特定SOTA方法约 <strong>2.1%</strong></li><li>在困难子集（Heavy Occlusion、Far）上优势更明显，提升达 <strong>3.5%-4.2%</strong></li><li>相比从头训练，提升 <strong>11.3%</strong>，证明预训练的有效性</li><li>相比ImageNet预训练，提升 <strong>6.8%</strong>，说明RGBT域内预训练的必要性</li></ul><p>在FLIR数据集上：</p><ul><li>三类平均mAP达到 <strong>76.4%</strong>，相比第二名提升 <strong>1.9%</strong></li><li>对于小目标（bicycle），提升尤为显著（<strong>+4.3%</strong>）</li></ul><h3 id="5-1-2-RGBT语义分割"><a href="#5-1-2-RGBT语义分割" class="headerlink" title="5.1.2 RGBT语义分割"></a>5.1.2 RGBT语义分割</h3><p><img data-src="/./../images/image-20251214105714507.png" alt="image-20251214105714507"></p><p>在MFNet数据集（城市场景）：</p><ul><li>M-SpecGene取得 <strong>mIoU 56.8%</strong>，超过RTFNet <strong>+2.5%</strong></li><li>在人、车、道路等关键类别上均有明显提升</li></ul><p>在PST900数据集（室内场景）：</p><ul><li>mIoU达到 <strong>82.3%</strong>，刷新记录</li><li>对于温度差异明显的类别（fire extinguisher、backpack）准确率提升显著</li></ul><h3 id="5-1-3-RGBT显著性检测"><a href="#5-1-3-RGBT显著性检测" class="headerlink" title="5.1.3 RGBT显著性检测"></a>5.1.3 RGBT显著性检测</h3><p><img data-src="/./../images/image-20251214105737756.png" alt="image-20251214105737756"></p><p>三个数据集综合表现：</p><table><thead><tr><th>数据集</th><th>F-measure</th><th>MAE</th><th>S-measure</th></tr></thead><tbody><tr><td>VT821</td><td>0.891</td><td>0.032</td><td>0.917</td></tr><tr><td>VT1000</td><td>0.908</td><td>0.028</td><td>0.929</td></tr><tr><td>VT5000</td><td>0.876</td><td>0.041</td><td>0.902</td></tr></tbody></table><ul><li>在所有指标上均超过CGFNet、APNet等专门方法</li><li>MAE显著降低，说明预测更精准</li></ul><h3 id="5-1-4-RGBT目标跟踪"><a href="#5-1-4-RGBT目标跟踪" class="headerlink" title="5.1.4 RGBT目标跟踪"></a>5.1.4 RGBT目标跟踪</h3><p><img data-src="/./../images/image-20251214105752154.png" alt="image-20251214105752154"></p><p>在RGBT234数据集：</p><ul><li>Success rate达到 <strong>67.2%</strong>，超过CAT <strong>+1.8%</strong></li><li>Precision达到 <strong>86.5%</strong></li></ul><p>在LasHeR数据集（更大规模、更多挑战）：</p><ul><li>Success rate <strong>62.9%</strong>，Precision <strong>79.3%</strong></li><li>在快速运动（FM）、尺度变化（SV）等挑战属性子集上表现优异</li></ul><h2 id="5-2-消融实验"><a href="#5-2-消融实验" class="headerlink" title="5.2 消融实验"></a>5.2 消融实验</h2><h3 id="5-2-1-CMSS度量的有效性"><a href="#5-2-1-CMSS度量的有效性" class="headerlink" title="5.2.1 CMSS度量的有效性"></a>5.2.1 CMSS度量的有效性</h3><p><img data-src="/./../images/image-20251214105825888.png" alt="image-20251214105825888"></p><p>对比四种掩码策略：</p><ol><li><strong>Random</strong>：随机掩码，RGB和热红外比例相同（0.75）</li><li><strong>Fixed</strong>：固定RGB掩码0.75，热红外0.5</li><li><strong>CMSS-only</strong>：仅基于CMSS确定掩码比例，无GMM</li><li><strong>GMM-CMSS</strong>（本文方法）：完整策略</li></ol><p>在KAIST检测任务上的结果：</p><ul><li>Random: mAP 78.2%</li><li>Fixed: mAP 80.4%（<strong>+2.2%</strong>）</li><li>CMSS-only: mAP 81.9%（<strong>+1.5%</strong>）</li><li>GMM-CMSS: mAP 83.7%（<strong>+1.8%</strong>）</li></ul><p>结论：</p><ul><li>简单地为两模态设置不同固定比例已有提升，证实了处理信息不平衡的必要性</li><li>引入CMSS自适应调整进一步提升性能</li><li>GMM建模带来额外增益，使掩码策略更灵活</li></ul><h3 id="5-2-2-渐进式调度的影响"><a href="#5-2-2-渐进式调度的影响" class="headerlink" title="5.2.2 渐进式调度的影响"></a>5.2.2 渐进式调度的影响</h3><p><img data-src="/./../images/image-20251214105932254.png" alt="image-20251214105932254"></p><p>对比三种调度方式：</p><ul><li><strong>Static</strong>：始终使用最大掩码比例</li><li><strong>Linear</strong>：线性增加</li><li><strong>Cosine</strong>：余弦调度（先慢后快）</li></ul><p>收敛速度与最终性能：</p><ul><li>Static：收敛慢，最终mAP 81.3%</li><li>Linear（本文采用）：收敛稳定，mAP 83.7%</li><li>Cosine：早期收敛快，但后期提升有限，mAP 82.9%</li></ul><p>结论：线性渐进调度在稳定性与性能间取得最佳平衡。</p><h3 id="5-2-3-对比学习损失的作用"><a href="#5-2-3-对比学习损失的作用" class="headerlink" title="5.2.3 对比学习损失的作用"></a>5.2.3 对比学习损失的作用</h3><p>移除对比损失后：</p><ul><li>检测mAP下降 <strong>1.4%</strong></li><li>分割mIoU下降 <strong>0.9%</strong></li><li>跟踪Success rate下降 <strong>0.7%</strong></li></ul><p>结论：对比损失增强了跨模态语义一致性，对密集预测任务（分割）和匹配任务（跟踪）尤为重要。</p><h3 id="5-2-4-预训练数据量的影响"><a href="#5-2-4-预训练数据量的影响" class="headerlink" title="5.2.4 预训练数据量的影响"></a>5.2.4 预训练数据量的影响</h3><p>分别使用25%、50%、75%、100%预训练数据：</p><ul><li>25%数据（~37K样本）：mAP 80.1%</li><li>50%数据：mAP 81.8%</li><li>75%数据：mAP 82.9%</li><li>100%数据（~150K样本）：mAP 83.7%</li></ul><p>观察：</p><ul><li>数据量增加带来稳定提升，但边际收益递减</li><li>即使在25%数据下，仍显著优于从头训练（<strong>+6.4%</strong>）</li><li>说明GMM-CMSS策略具有较高的数据利用效率</li></ul><h2 id="5-3-可视化分析"><a href="#5-3-可视化分析" class="headerlink" title="5.3 可视化分析"></a>5.3 可视化分析</h2><h3 id="5-3-1-学习到的表示可视化"><a href="#5-3-1-学习到的表示可视化" class="headerlink" title="5.3.1 学习到的表示可视化"></a>5.3.1 学习到的表示可视化</h3><p>使用t-SNE可视化在KAIST验证集上提取的特征：</p><ul><li><strong>从头训练</strong>：类内分散，类间重叠严重</li><li><strong>ImageNet预训练</strong>：RGB分支特征较好，但热红外分支混乱</li><li><strong>单模态MAE</strong>：两模态特征分布不一致</li><li><strong>M-SpecGene</strong>：类内紧凑，类间分离清晰，两模态对齐良好</li></ul><p>结论：M-SpecGene学习到了更具判别性和模态一致性的表示。</p><h3 id="5-3-2-注意力图分析"><a href="#5-3-2-注意力图分析" class="headerlink" title="5.3.2 注意力图分析"></a>5.3.2 注意力图分析</h3><p>可视化最后一层Transformer的注意力权重：</p><ul><li><strong>单模态MAE</strong>：注意力分散，背景干扰多</li><li><strong>RGBT联合MAE</strong>：有一定目标关注，但两模态注意力不一致</li><li><strong>M-SpecGene</strong>：强烈聚焦于目标区域，背景被有效抑制，两模态注意力高度一致</li></ul><p>结论：目标感知掩码策略引导模型学习以对象为中心的表示。</p><h3 id="5-3-3-掩码重建质量"><a href="#5-3-3-掩码重建质量" class="headerlink" title="5.3.3 掩码重建质量"></a>5.3.3 掩码重建质量</h3><p>展示几组高难度场景的重建结果：</p><ol><li><strong>夜间低照度</strong>：RGB几乎全黑，模型成功从热红外推断出目标轮廓并重建RGB结构</li><li><strong>强光过曝</strong>：RGB过曝丢失细节，重建时从热红外补充温度信息</li><li><strong>遮挡场景</strong>：部分遮挡的目标被完整重建</li></ol><p>结论：模型学会了跨模态互补，能在一个模态信息缺失时利用另一模态进行推理。</p><h2 id="5-4-跨数据集泛化能力"><a href="#5-4-跨数据集泛化能力" class="headerlink" title="5.4 跨数据集泛化能力"></a>5.4 跨数据集泛化能力</h2><p>在KAIST上预训练，迁移到其他数据集（零样本或少样本微调）：</p><table><thead><tr><th>目标数据集</th><th>零样本mAP</th><th>10-shot mAP</th><th>全量微调mAP</th></tr></thead><tbody><tr><td>FLIR</td><td>51.2%</td><td>68.7%</td><td>76.4%</td></tr><tr><td>M3FD</td><td>48.9%</td><td>65.3%</td><td>73.1%</td></tr></tbody></table><p>对比基线（ImageNet预训练）：</p><ul><li>零样本：M-SpecGene <strong>+15.3%</strong></li><li>10-shot：M-SpecGene <strong>+8.9%</strong></li></ul><p>结论：M-SpecGene具有强大的跨数据集泛化能力，尤其在数据稀缺（零样本、少样本）场景下优势显著。</p><hr><h1 id="6-讨论与分析"><a href="#6-讨论与分析" class="headerlink" title="6. 讨论与分析"></a>6. 讨论与分析</h1><h2 id="6-1-为什么CMSS度量有效？"><a href="#6-1-为什么CMSS度量有效？" class="headerlink" title="6.1 为什么CMSS度量有效？"></a>6.1 为什么CMSS度量有效？</h2><p>CMSS的成功源于其<strong>理论简洁性</strong>与<strong>实践有效性</strong>的结合：</p><ol><li><strong>理论合理性</strong>：信息论角度，信息熵与像素方差存在关联；CMSS通过标准差近似捕获了信息密度差异</li><li><strong>计算高效</strong>：无需复杂模型，单次前向计算即可获得</li><li><strong>自适应性</strong>：不同场景、不同样本的CMSS值不同，允许样本级自适应掩码</li></ol><p>然而，CMSS也存在局限：</p><ul><li>仅考虑低层统计特征，未捕获高层语义信息</li><li>对噪声敏感，需预处理去噪</li></ul><p>未来可探索基于深度特征的信息密度估计方法。</p><h2 id="6-2-GMM建模的必要性"><a href="#6-2-GMM建模的必要性" class="headerlink" title="6.2 GMM建模的必要性"></a>6.2 GMM建模的必要性</h2><p>为什么不直接用CMSS线性映射到掩码比例？</p><p>GMM带来的优势：</p><ol><li><strong>非线性映射</strong>：CMSS与最优掩码比例关系可能非线性，GMM通过混合分量捕获复杂映射</li><li><strong>鲁棒性</strong>：GMM对异常值不敏感，避免极端CMSS导致不合理掩码</li><li><strong>可解释性</strong>：每个高斯分量可对应一类场景（如”RGB主导”、”平衡”、”热红外主导”）</li></ol><p>消融实验证实，GMM相比简单线性映射提升约1.8%，验证了其必要性。</p><h2 id="6-3-与特定任务方法的对比"><a href="#6-3-与特定任务方法的对比" class="headerlink" title="6.3 与特定任务方法的对比"></a>6.3 与特定任务方法的对比</h2><p>M-SpecGene在多数任务上超过特定任务SOTA，但在某些任务上仍有差距（如显著性检测在某些指标上与最优方法持平）。原因分析：</p><p><strong>优势来源</strong>：</p><ul><li><strong>通用表示</strong>：预训练学习的特征具有良好的可迁移性</li><li><strong>数据增强</strong>：预训练利用了多个数据集，见过更多样化的场景</li><li><strong>正则化效应</strong>：大规模预训练避免下游任务过拟合</li></ul><p><strong>仍存在差距的原因</strong>：</p><ul><li>某些任务特定设计（如显著性检测的边界细化模块）在微调时未充分利用</li><li>预训练目标（重建）与某些任务目标（如跟踪的时序建模）存在gap</li></ul><p>未来可探索多任务联合预训练或更任务相关的预训练目标。</p><h2 id="6-4-计算效率分析"><a href="#6-4-计算效率分析" class="headerlink" title="6.4 计算效率分析"></a>6.4 计算效率分析</h2><p>预训练开销：</p><ul><li>800 epoch，8卡V100，约<strong>120小时</strong></li><li>相比ImageNet预训练（300 epoch，约80小时）稍长，但考虑到多模态处理，开销可接受</li></ul><p>下游微调开销：</p><ul><li>各任务微调时间在2-8小时，与从头训练相当</li><li>推理速度：ViT-Base约<strong>35 FPS</strong>（单卡V100），满足实时性要求</li></ul><p>与特定任务轻量级方法相比，M-SpecGene计算量较大，但通过一次预训练支持多任务，总体效率更高。</p><h2 id="6-5-模态偏置的量化分析"><a href="#6-5-模态偏置的量化分析" class="headerlink" title="6.5 模态偏置的量化分析"></a>6.5 模态偏置的量化分析</h2><p>为验证M-SpecGene确实缓解了模态偏置，设计以下实验：</p><p><strong>方法</strong>：在测试时分别屏蔽一个模态，观察性能下降程度。若模型对某模态过度依赖，屏蔽该模态后性能将大幅下降。</p><table><thead><tr><th>方法</th><th>完整双模态</th><th>仅RGB</th><th>仅热红外</th><th>RGB下降</th><th>热红外下降</th></tr></thead><tbody><tr><td>从头训练</td><td>72.4%</td><td>68.1%</td><td>51.2%</td><td>-4.3%</td><td><strong>-21.2%</strong></td></tr><tr><td>ImageNet预训练</td><td>76.9%</td><td>73.5%</td><td>54.7%</td><td>-3.4%</td><td><strong>-22.2%</strong></td></tr><tr><td>RGBT联合MAE</td><td>79.8%</td><td>75.2%</td><td>59.6%</td><td>-4.6%</td><td><strong>-20.2%</strong></td></tr><tr><td>M-SpecGene</td><td>83.7%</td><td>77.3%</td><td>71.9%</td><td>-6.4%</td><td><strong>-11.8%</strong></td></tr></tbody></table><p>观察：</p><ul><li>所有基线方法在屏蔽热红外后性能暴跌20%+，而M-SpecGene仅下降11.8%</li><li>M-SpecGene的RGB分支下降幅度反而更大（6.4% vs. 3-4%），说明模型更平衡地利用两模态</li><li>单独使用热红外时，M-SpecGene仍能达到71.9%，远超其他方法（51-59%），证明热红外分支被充分训练</li></ul><p>结论：M-SpecGene成功实现了模态平衡，避免了对RGB的过度依赖。</p><hr><h1 id="7-局限性与未来工作"><a href="#7-局限性与未来工作" class="headerlink" title="7. 局限性与未来工作"></a>7. 局限性与未来工作</h1><h2 id="7-1-当前局限性"><a href="#7-1-当前局限性" class="headerlink" title="7.1 当前局限性"></a>7.1 当前局限性</h2><ol><li><p><strong>预训练数据规模</strong></p><p>相比单模态视觉（ImageNet 1.2M），RGBT数据仍较稀缺（~150K）。虽然GMM-CMSS提高了数据效率，但更大规模数据仍可能带来进一步提升。</p></li><li><p><strong>计算成本</strong></p><p>ViT架构的自注意力机制计算复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.02778em">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:.10903em">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，在高分辨率图像上开销较大。未来可探索线性复杂度的Transformer变体（如Linformer、Performer）。</p></li><li><p><strong>CMSS度量的简化假设</strong></p><p>当前CMSS基于像素标准差，未考虑语义信息。在某些极端场景（如单色背景 + 低温目标），CMSS可能失效。</p></li><li><p><strong>预训练-微调gap</strong></p><p>某些任务（如目标跟踪）需要时序建模，而预训练仅在静态图像上进行，导致迁移效果受限。</p></li></ol><h2 id="7-2-未来研究方向"><a href="#7-2-未来研究方向" class="headerlink" title="7.2 未来研究方向"></a>7.2 未来研究方向</h2><h3 id="7-2-1-扩展到更多模态"><a href="#7-2-1-扩展到更多模态" class="headerlink" title="7.2.1 扩展到更多模态"></a>7.2.1 扩展到更多模态</h3><p>RGBT仅是多光谱视觉的一个子集，未来可扩展到：</p><ul><li><strong>RGB-Depth-Thermal</strong>（三模态融合）</li><li><strong>多光谱卫星图像</strong>（可见光 + 多个红外波段）</li><li><strong>医学影像</strong>（CT + MRI融合）</li></ul><p>GMM-CMSS框架可推广到多模态场景，为每对模态计算信息密度差异。</p><h3 id="7-2-2-视频预训练"><a href="#7-2-2-视频预训练" class="headerlink" title="7.2.2 视频预训练"></a>7.2.2 视频预训练</h3><p>引入时序维度：</p><ul><li>在RGBT视频数据上进行时空掩码建模</li><li>学习运动、遮挡、光照变化等时序模式</li><li>提升在目标跟踪、动作识别等视频任务上的性能</li></ul><h3 id="7-2-3-可学习的信息密度估计"><a href="#7-2-3-可学习的信息密度估计" class="headerlink" title="7.2.3 可学习的信息密度估计"></a>7.2.3 可学习的信息密度估计</h3><p>用神经网络替代手工设计的CMSS：</p><ul><li>端到端学习信息密度估计器</li><li>联合优化掩码策略与重建目标</li><li>自适应不同数据分布</li></ul><h3 id="7-2-4-轻量化与移动端部署"><a href="#7-2-4-轻量化与移动端部署" class="headerlink" title="7.2.4 轻量化与移动端部署"></a>7.2.4 轻量化与移动端部署</h3><p>针对资源受限场景：</p><ul><li>知识蒸馏：用M-SpecGene教师模型训练轻量学生模型</li><li>模型剪枝与量化</li><li>神经架构搜索（NAS）自动设计高效架构</li></ul><h3 id="7-2-5-开放世界泛化"><a href="#7-2-5-开放世界泛化" class="headerlink" title="7.2.5 开放世界泛化"></a>7.2.5 开放世界泛化</h3><p>当前模型在预定义类别上表现优异，但对开放世界（novel categories）的泛化能力有限。未来可探索：</p><ul><li>零样本RGBT检测（结合视觉-语言模型如CLIP）</li><li>Few-shot学习（元学习框架下快速适应新类别）</li><li>持续学习（不断吸收新数据而不遗忘旧知识）</li></ul><hr><h1 id="8-结论"><a href="#8-结论" class="headerlink" title="8. 结论"></a>8. 结论</h1><p>本文提出M-SpecGene，首次尝试构建面向RGBT多光谱视觉的通用基础模型。针对RGBT数据的信息不平衡问题，创新性地提出跨模态结构稀疏性（CMSS）度量，并基于此设计GMM-CMSS渐进式掩码策略，实现灵活、平衡、以目标为中心的自监督预训练。</p><p>大规模实验证明，M-SpecGene在<strong>11个数据集</strong>和<strong>4类下游任务</strong>（目标检测、语义分割、显著性检测、目标跟踪）上均取得优异性能，超过任务特定设计的SOTA方法。更重要的是，M-SpecGene将此前分散的逐任务研究统一到一个预训练-微调范式下，为多光谱视觉研究提供了新的方向。</p><p>从方法论角度，M-SpecGene展示了如何针对物理多模态数据的特性（信息不平衡）设计自监督学习策略，这一思路可推广到其他多模态场景。从实践角度，M-SpecGene降低了RGBT应用的开发门槛——无需从头设计复杂融合架构，仅需在预训练模型上微调即可获得强大性能。</p><p>随着RGBT数据的持续积累和计算资源的提升，基础模型范式有望成为多光谱视觉的主流方案。未来工作将聚焦于扩展模态类型、引入时序建模、提升开放世界泛化能力，推动多光谱视觉向更通用、更鲁棒的方向发展。</p></div><footer class="post-footer"><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>MaJianyu</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://mjy.js.org/2025/12/13/%E3%80%90%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%20%20ICCV%202025%20%20M-SpecGene%EF%BC%9A%E9%9D%A2%E5%90%91%20RGBT%20%E5%A4%9A%E5%85%89%E8%B0%B1%E8%A7%86%E8%A7%89%E7%9A%84%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9E%8B%E3%80%91/" title="【论文阅读 | ICCV 2025 | M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】">https://mjy.js.org/2025/12/13/【论文阅读 ICCV 2025 M-SpecGene：面向 RGBT 多光谱视觉的通用基础模型】/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E5%A4%9A%E5%85%89%E8%B0%B1%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/" rel="tag"># 多光谱目标检测</a> <a href="/tags/MAE/" rel="tag"># MAE</a> <a href="/tags/%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/" rel="tag"># 共享参数</a> <a href="/tags/%E8%B7%A8%E5%8F%82%E6%95%B0%E4%BA%A4%E4%BA%92/" rel="tag"># 跨参数交互</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2025/12/09/2025.12.09%20C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E4%B9%A0%E5%85%AD/" rel="prev" title="2025.12.09 C语言程序设计上机实习六"><i class="fa fa-angle-left"></i> 2025.12.09 C语言程序设计上机实习六</a></div><div class="post-nav-item"><a href="/2025/12/16/2025.12.16%20C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8A%E6%9C%BA%E5%AE%9E%E4%B9%A0%E4%B8%83/" rel="next" title="2025.12.16 C语言程序设计上机实习七">2025.12.16 C语言程序设计上机实习七 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2021 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">MaJianyu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span>站点总字数：</span> <span title="站点总字数">336k</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span>站点阅读时长 &asymp;</span> <span title="站点阅读时长">10:11</span></span></div><div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动</div><a href="https://icp.gov.moe/?keyword=20216556" target="_blank">萌ICP备20216556号</a></div></footer><div class="toggle sidebar-toggle" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><div class="sidebar-dimmer"></div><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><a href="https://github.com/majianyu2007" class="github-corner" title="在 GitHub 上关注我" aria-label="在 GitHub 上关注我" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://mjy.js.org/js/darkmode@1.5.7.min.js"></script><script>var options = {
  bottom: '16px',
  right: '16px',
  left: 'unset',
  time: '0.5s',
  mixColor: 'transparent',
  backgroundColor: 'transparent',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '🌓',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();</script></body></html>